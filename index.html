<!DOCTYPE html>
<!-- NeuroConstellation Web v1.0 | (c) 2025 Safeer Ali Mirani, University of Sassari | EBRAINS-Italy -->

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuroConstellation Web ‚Äî GPU-Accelerated Neural Visualisation</title>
    <meta name="description" content="NeuroConstellation Web: Real-time WebGPU visualisation of large-scale hippocampal neural networks. Supports 288K‚Äì5.28M neurons with 6 scientifically validated visualisation modes. Port of the Unity NeuroConstellation platform.">
    <meta name="author" content="Safeer Ali Mirani, Pirah Memon, Paolo Enrico, Sergio M.G. Solinas">
    <meta name="keywords" content="neural visualisation, WebGPU, hippocampus, GPU computing, computational neuroscience, spike detection, real-time rendering">
    <meta name="application-name" content="NeuroConstellation Web">
    <meta name="version" content="1.0.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='%23050508'/><circle cx='50' cy='20' r='5' fill='%2300ff88'/><circle cx='20' cy='50' r='5' fill='%230099ff'/><circle cx='80' cy='50' r='5' fill='%239966ff'/><circle cx='50' cy='80' r='5' fill='%2300ff88'/><circle cx='50' cy='50' r='8' fill='%2300ff88'/></svg>">
    <meta property="og:title" content="NeuroConstellation Web ‚Äî GPU-Accelerated Neural Visualisation">
    <meta property="og:description" content="Real-time WebGPU visualisation of large-scale hippocampal neural networks with 6 validated visualisation modes.">
    <meta property="og:type" content="website">
    <style>
*{margin:0;padding:0;box-sizing:border-box}:root{--primary:#00ff88;--primary-dark:#00cc6a;--bg:#0a0a0a;--panel:rgba(15,15,15,0.95);--border:rgba(255,255,255,0.1);--text:#ffffff;--text2:#a0a0a0;--blue:#0099ff;--purple:#9966ff;--error:#ff4444;--inactive:#3366ff;--gradient-low:#3333cc;--gradient-mid:#00ffcc;--gradient-high:#ffcc00;--gradient-max:#ff3300}body{font-family:'Inter',-apple-system,BlinkMacSystemFont,sans-serif;background:var(--bg);color:var(--text);overflow:hidden;line-height:1.5}canvas#gpuCanvas{position:absolute;top:0;left:0;width:100%;height:100%;cursor:grab;background:#000}canvas#gpuCanvas:active{cursor:grabbing}.intro-overlay{position:fixed;inset:0;z-index:2000;background:radial-gradient(ellipse at 50% 30%,rgba(0,40,80,0.3),#050508 70%);display:flex;align-items:center;justify-content:center;opacity:1;transition:opacity 0.8s ease-out}.intro-overlay.hidden{opacity:0;pointer-events:none}.intro-box{text-align:center;max-width:760px;padding:40px;animation:fadeUp 1s ease-out;max-height:92vh;overflow-y:auto;position:relative}.intro-glow{position:absolute;top:-120px;left:50%;transform:translateX(-50%);width:400px;height:400px;border-radius:50%;background:radial-gradient(circle,rgba(0,255,136,0.08),transparent 70%);pointer-events:none;animation:pulse 4s ease-in-out infinite}@keyframes pulse{0%,100%{opacity:0.5;transform:translateX(-50%) scale(1)}50%{opacity:1;transform:translateX(-50%) scale(1.1)}}@keyframes fadeUp{from{opacity:0;transform:translateY(30px)}to{opacity:1;transform:translateY(0)}}.intro-badge{display:inline-block;padding:5px 16px;border-radius:20px;font-size:11px;font-weight:600;letter-spacing:1.5px;text-transform:uppercase;background:rgba(0,255,136,0.1);border:1px solid rgba(0,255,136,0.2);color:var(--primary);margin-bottom:16px}.intro-box h1{font-size:42px;font-weight:800;margin-bottom:12px;letter-spacing:-0.5px;background:linear-gradient(135deg,#00ff88 0%,#00ccff 50%,#9966ff 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;animation:fadeUp 1s ease-out 0.1s both}.web-suffix{font-weight:300;opacity:0.8;font-size:36px}.intro-box .subtitle{font-size:14px;color:var(--text2);margin-bottom:28px;line-height:1.8;animation:fadeUp 1s ease-out 0.2s both}.intro-card{margin-bottom:20px;padding:22px;background:rgba(255,255,255,0.03);border-radius:14px;border:1px solid rgba(255,255,255,0.06);animation:fadeUp 1s ease-out 0.3s both}.intro-card .name{font-size:26px;font-weight:700;color:var(--primary);margin-bottom:6px}.intro-card .role{font-size:15px;color:var(--text)}.intro-card .affil{font-size:13px;color:var(--text2)}.intro-card .fund{font-size:13px;color:var(--blue);font-style:italic;margin-top:4px}.intro-card a{font-size:13px;color:var(--primary);text-decoration:none}.collab-card{margin-bottom:20px;padding:18px;background:rgba(0,153,255,0.05);border-radius:12px;border:1px solid rgba(0,153,255,0.1);animation:fadeUp 1s ease-out 0.4s both}.collab-card .label{font-size:11px;color:var(--text2);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px}.collab-card .cname{font-size:18px;font-weight:600;color:var(--blue)}.collab-card .crole{font-size:13px;color:var(--text2)}.super-card{margin-bottom:20px;padding:18px;background:rgba(0,255,136,0.04);border-radius:12px;border:1px solid rgba(0,255,136,0.1);animation:fadeUp 1s ease-out 0.5s both}.super-card .label{font-size:11px;color:var(--text2);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px}.super-card .names{display:flex;justify-content:center;gap:28px}.super-card .names span{font-size:17px;font-weight:600;color:var(--primary)}.ack-card{margin-bottom:28px;padding:18px;background:rgba(255,255,255,0.02);border-radius:12px;border:1px solid rgba(255,255,255,0.05);font-size:13px;color:var(--text2);line-height:1.7;font-style:italic;animation:fadeUp 1s ease-out 0.6s both}.ack-card .label{font-size:11px;color:var(--text2);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;font-style:normal;font-weight:600}.enter-btn{padding:16px 44px;display:inline-flex;align-items:center;gap:8px;background:linear-gradient(135deg,var(--primary),#00ccff);color:#050508;border:none;border-radius:30px;font-size:16px;font-weight:700;cursor:pointer;box-shadow:0 4px 24px rgba(0,255,136,0.35),0 0 60px rgba(0,255,136,0.1);transition:all 0.3s;animation:fadeUp 1s ease-out 0.7s both}.enter-btn:hover{transform:translateY(-3px) scale(1.02);box-shadow:0 8px 36px rgba(0,255,136,0.5),0 0 80px rgba(0,255,136,0.15)}.enter-icon{font-size:18px}.tech-section{margin-top:22px;animation:fadeUp 1s ease-out 0.8s both}.tech-row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}.tech-badge{padding:3px 11px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:16px;font-size:11px;color:var(--text2)}.shortcut-preview{display:flex;gap:16px;justify-content:center;flex-wrap:wrap;margin-top:14px;font-size:11px;color:rgba(255,255,255,0.25)}.shortcut-preview span{letter-spacing:0.3px}.loading-overlay{position:fixed;inset:0;z-index:1500;background:var(--bg);display:none;flex-direction:column;align-items:center;justify-content:center;transition:opacity 0.5s}.loading-overlay.visible{display:flex}.loading-overlay.fade{opacity:0}.loading-box{text-align:center;max-width:400px}.loading-box h2{font-size:22px;font-weight:600;margin-bottom:8px;background:linear-gradient(135deg,var(--primary),var(--blue));-webkit-background-clip:text;-webkit-text-fill-color:transparent}.loading-box .sub{color:var(--text2);margin-bottom:24px;font-size:14px}.progress-track{width:100%;height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;margin-bottom:16px}.progress-fill{height:100%;background:linear-gradient(90deg,var(--primary),var(--blue));width:0%;transition:width 0.3s}.loading-status{font-size:13px;color:var(--text2)}.error-overlay{position:fixed;inset:0;z-index:3000;background:var(--bg);display:none;flex-direction:column;align-items:center;justify-content:center}.error-overlay.visible{display:flex}.error-box{text-align:center;max-width:500px;padding:40px}.error-box h2{font-size:24px;color:var(--error);margin-bottom:16px}.error-box p{color:var(--text2);margin-bottom:12px;font-size:14px;line-height:1.6}.error-box a{color:var(--primary)}.header{position:absolute;top:0;left:0;right:0;height:56px;background:linear-gradient(180deg,rgba(5,5,8,0.95) 0%,rgba(5,5,8,0.7) 70%,transparent 100%);display:flex;align-items:center;justify-content:space-between;padding:0 28px;z-index:100;transition:opacity 0.3s,transform 0.3s}.header.hidden{opacity:0;pointer-events:none}.logo{display:flex;align-items:center;gap:10px}.logo svg{width:28px;height:28px}.logo span{font-size:17px;font-weight:600;background:linear-gradient(135deg,var(--primary),var(--blue));-webkit-background-clip:text;-webkit-text-fill-color:transparent}.hstats{display:flex;gap:28px}.hstat{text-align:center}.hstat .val{font-size:18px;font-weight:600;color:var(--primary)}.hstat .lbl{font-size:11px;color:var(--text2);text-transform:uppercase;letter-spacing:0.5px}.cpanel{position:absolute;top:72px;left:28px;width:340px;background:var(--panel);backdrop-filter:blur(20px);border:1px solid var(--border);border-radius:14px;box-shadow:0 10px 40px rgba(0,0,0,0.5);z-index:100;transition:opacity 0.3s,transform 0.3s;max-height:calc(100vh - 100px);overflow-y:auto}.cpanel.hidden{opacity:0;transform:translateX(-20px);pointer-events:none}.cpanel-head{padding:16px 18px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between}.cpanel-head h3{font-size:15px;font-weight:600}.cpanel-head button{background:none;border:none;color:var(--text2);cursor:pointer;width:24px;height:24px;border-radius:6px;display:flex;align-items:center;justify-content:center}.cpanel-head button:hover{background:rgba(255,255,255,0.1);color:var(--text)}.cpanel-body{padding:16px 18px}.csection{margin-bottom:20px}.csection:last-child{margin-bottom:0}.csection-title{font-size:11px;font-weight:600;color:var(--text2);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:12px}.citem{margin-bottom:14px}.citem-label{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;font-size:13px}.citem-val{font-weight:600;color:var(--primary);font-family:'SF Mono','Monaco','Consolas',monospace;font-size:12px}.slider-wrap{position:relative;height:28px;cursor:pointer}.slider-track{position:absolute;top:12px;left:0;right:0;height:4px;background:rgba(255,255,255,0.1);border-radius:2px}.slider-fill{position:absolute;top:0;left:0;height:100%;background:linear-gradient(90deg,var(--primary),var(--primary-dark));border-radius:2px}.slider-thumb{position:absolute;top:8px;width:12px;height:12px;background:var(--primary);border-radius:50%;box-shadow:0 2px 8px rgba(0,255,136,0.5);transform:translateX(-50%);transition:transform 0.1s}.slider-wrap:hover .slider-thumb{transform:translateX(-50%) scale(1.2)}.toggle-row{display:flex;align-items:center;justify-content:space-between;cursor:pointer;font-size:13px}.toggle-track{position:relative;width:40px;height:22px;background:rgba(255,255,255,0.1);border-radius:11px;transition:background 0.3s;flex-shrink:0}.toggle-track.on{background:var(--primary)}.toggle-knob{position:absolute;top:2px;left:2px;width:18px;height:18px;background:#fff;border-radius:50%;transition:transform 0.3s;box-shadow:0 2px 4px rgba(0,0,0,0.2)}.toggle-track.on .toggle-knob{transform:translateX(18px)}.mode-btns{display:flex;gap:6px;flex-wrap:wrap}.mode-btn{flex:1;min-width:80px;padding:8px 12px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);color:var(--text2);border-radius:8px;font-size:12px;font-weight:500;cursor:pointer;transition:all 0.2s;text-align:center}.mode-btn.active{background:var(--primary);color:var(--bg);border-color:var(--primary);font-weight:600}.mode-btn:hover:not(.active){background:rgba(255,255,255,0.12);color:var(--text)}.btn{width:100%;padding:10px 18px;border:none;border-radius:8px;font-size:13px;font-weight:600;cursor:pointer;transition:all 0.3s}.btn-primary{background:var(--primary);color:var(--bg)}.btn-primary:hover{background:var(--primary-dark);transform:translateY(-1px);box-shadow:0 4px 12px rgba(0,255,136,0.4)}.btn-secondary{background:rgba(255,255,255,0.1);color:var(--text)}.btn-secondary:hover{background:rgba(255,255,255,0.15)}.cpick-row{display:flex;align-items:center;gap:10px;margin-bottom:10px}.cpick-swatch{width:28px;height:28px;border-radius:6px;border:2px solid rgba(255,255,255,0.2);cursor:pointer;transition:all 0.2s}.cpick-swatch:hover{transform:scale(1.1);border-color:var(--primary)}.cpick-input{position:absolute;opacity:0;pointer-events:none}.cpick-hex{font-size:12px;color:var(--text2);font-family:'SF Mono','Monaco','Consolas',monospace}.timeline{height:42px;background:rgba(255,255,255,0.05);border-radius:8px;position:relative;cursor:pointer;overflow:hidden;margin-bottom:12px}.timeline-fill{position:absolute;top:0;left:0;height:100%;background:linear-gradient(90deg,var(--primary),var(--blue));opacity:0.2;transition:width 0.1s}.timeline-info{position:absolute;top:50%;left:14px;transform:translateY(-50%);display:flex;align-items:center;gap:10px;pointer-events:none}.timeline-time{font-size:13px;font-weight:600;color:var(--text);min-width:55px}.timeline-total{font-size:11px;color:var(--text2)}.perfmon{position:absolute;top:60px;right:28px;background:var(--panel);backdrop-filter:blur(20px);border:1px solid var(--border);border-radius:12px;padding:10px 14px;min-width:170px;box-shadow:0 10px 40px rgba(0,0,0,0.5);z-index:100;transition:opacity 0.3s,transform 0.3s}.perfmon.hidden{opacity:0;transform:translateX(20px);pointer-events:none}.perfmon h4{font-size:11px;font-weight:600;color:var(--text2);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:10px}.pstat{display:flex;justify-content:space-between;margin-bottom:3px;font-size:11px}.pstat .plbl{color:var(--text2)}.pstat .pval{font-weight:600;font-family:'SF Mono','Monaco','Consolas',monospace}.fps-hi{color:var(--primary)}.fps-md{color:var(--blue)}.fps-lo{color:var(--error)}.infobar{position:absolute;bottom:0;left:0;right:0;height:28px;background:rgba(5,5,8,0.9);border-top:1px solid var(--border);display:flex;gap:8px;align-items:center;justify-content:center;z-index:90;overflow:hidden;transition:opacity 0.3s;font-size:10px}.infobar.hidden{opacity:0;pointer-events:none}.infobar .iitem{display:flex;align-items:center;gap:4px;color:var(--text2)}.fab{position:fixed;bottom:20px;right:20px;width:46px;height:46px;border-radius:50%;background:rgba(10,10,10,0.9);border:2px solid rgba(0,255,136,0.5);color:var(--primary);cursor:pointer;z-index:999;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 20px rgba(0,0,0,0.5);backdrop-filter:blur(10px);transition:all 0.2s}.fab:hover{transform:scale(1.1);background:rgba(0,255,136,0.3);box-shadow:0 0 20px rgba(0,255,136,0.5)}.dataset-btns{display:flex;gap:4px}.ds-btn{flex:1;padding:6px 8px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:var(--text2);border-radius:6px;font-size:11px;font-weight:500;cursor:pointer;transition:all 0.2s;text-align:center}.ds-btn.active{background:var(--blue);color:#fff;border-color:var(--blue)}.ds-btn:hover:not(.active){background:rgba(255,255,255,0.1)}::-webkit-scrollbar{width:6px}::-webkit-scrollbar-track{background:rgba(255,255,255,0.05);border-radius:3px}::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.2);border-radius:3px}@media (max-width:768px){.cpanel{left:16px;right:16px;width:auto;max-width:360px}.perfmon{display:none}.hstats{display:none}.infobar{display:none}}.kb-toast{position:fixed;bottom:80px;left:50%;transform:translateX(-50%) translateY(20px);padding:10px 24px;background:rgba(0,0,0,0.85);backdrop-filter:blur(10px);border:1px solid rgba(0,255,136,0.3);border-radius:24px;color:var(--primary);font-size:14px;font-weight:600;z-index:200;opacity:0;transition:opacity 0.3s,transform 0.3s;pointer-events:none;font-family:'SF Mono','Monaco','Consolas',monospace}.kb-toast.show{opacity:1;transform:translateX(-50%) translateY(0)}@keyframes recBlink{0%,100%{opacity:1}50%{opacity:0.3}}#recBadge{display:none}#recBadge.show{display:flex}.cite-block{font-size:11px;color:var(--text2);line-height:1.6;margin-top:8px}
</style>
</head>
<body>
    <canvas id="gpuCanvas"></canvas>
    <div class="intro-overlay" id="introOverlay">
        <div class="intro-box">
            <div class="intro-glow"></div>
            <div class="intro-badge">WebGPU Neural Visualisation Platform</div>
            <h1>NeuroConstellation<span class="web-suffix">Web</span></h1>
            <p class="subtitle">Real-time GPU-accelerated visualisation of large-scale hippocampal neural networks<br>288K‚Äì5.28M neurons ¬∑ WGSL compute shader spike detection ¬∑ 6 validated visualisation modes</p>
            <div class="intro-card">
                <div class="name">Safeer Ali Mirani</div>
                <div class="role">PhD Candidate, Department of Life Sciences and Biotechnologies</div>
                <div class="affil">University of Sassari (UNISS), Italy</div>
                <div class="fund">Funded by EBRAINS-Italy ¬∑ MUR-PNRR M4.C2.I1.4 ¬∑ CUP B51E22000150006</div>
                <a href="mailto:safeer.ali.mirani@gmail.com">safeer.ali.mirani@gmail.com</a>
            </div>
            <div class="collab-card">
                <div class="label">In Collaboration With</div>
                <div class="cname">Pirah Memon</div>
                <div class="crole">Researcher, Department of Life Sciences and Biotechnologies, University of Sassari (UNISS), Italy</div>
            </div>
            <div class="super-card">
                <div class="label">Under the Kind Supervision of</div>
                <div class="names">
                    <span>Prof. Dr. Paolo Enrico</span>
                    <span>Prof. Dr. Sergio M.G. Solinas</span>
                </div>
                <div style="text-align:center;margin-top:6px;"><a href="mailto:smgsolinas@uniss.it" style="font-size:13px;color:var(--primary);text-decoration:none;">smgsolinas@uniss.it</a></div>
            </div>
            <div class="ack-card">
                <div class="label">Acknowledgments</div>
                <div>We express our sincere gratitude to Prof. Dr. Paolo Enrico and Prof. Dr. Sergio M.G. Solinas for their kind and continuous supervision and support throughout this research.</div>
                <div style="margin-top:6px;">This research was funded by Project IR00011 EBRAINS-Italy, Mission 4 'Istruzione e Ricerca', Component 2 'Dalla ricerca all'impresa', Line of investment 3.1 of PNRR (European Union NextGeneration EU, CUP B51E22000150006).</div>
                <div class="cite-block" style="margin-top:10px;border-top:1px solid rgba(255,255,255,0.06);padding-top:8px;font-style:normal;">
                    <strong style="color:var(--text);font-size:10px;">Cite as:</strong><br>
                    Mirani, S.A., Memon, P., Enrico, P., & Solinas, S.M.G. (2025). NeuroConstellation Web: Browser-Based GPU-Accelerated Neural Network Visualisation. University of Sassari.<br>
                    <span style="color:rgba(255,255,255,0.3);">Part of PhD Thesis: "Real-Time Visualisation of Large-Scale Neural Networks: GPU-Accelerated Methods for Desktop and Mixed Reality Platforms"</span>
                </div>
            </div>
            <button class="enter-btn" id="enterBtn">
                <span class="enter-icon">‚ö°</span> Enter Visualisation
            </button>
            <div class="tech-section">
                <div class="tech-row">
                    <span class="tech-badge">WebGPU</span>
                    <span class="tech-badge">WGSL Compute</span>
                    <span class="tech-badge">Billboard Instancing</span>
                    <span class="tech-badge">Binary Streaming</span>
                    <span class="tech-badge">6 Visualisation Modes</span>
                </div>
                <div class="shortcut-preview">
                    <span>Space: Play</span>
                    <span>‚Üë‚Üì: Speed</span>
                    <span>‚Üê‚Üí: Seek</span>
                    <span>W/S: Window</span>
                    <span>Q/E: Scale</span>
                    <span>1-6: Modes</span>
                    <span>F: Fullscreen</span>
                    <span>H: Hide UI</span>
                </div>
            </div>
        </div>
    </div>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-box">
            <h2>NeuroConstellation Web</h2>
            <p class="sub" id="loadingSub">Initialising WebGPU...</p>
            <div class="progress-track"><div class="progress-fill" id="progressFill"></div></div>
            <p class="loading-status" id="loadingStatus">Requesting GPU adapter...</p>
        </div>
    </div>
    <div class="error-overlay" id="errorOverlay">
        <div class="error-box">
            <h2>Initialisation Error</h2>
            <p class="err-msg" style="color:#ff6b6b;font-family:monospace;font-size:13px;background:rgba(255,0,0,0.08);padding:12px;border-radius:8px;margin-bottom:16px;">Unknown error</p>
            <p>This visualisation requires <strong>WebGPU</strong> support:</p>
            <p style="margin-top:8px;font-size:13px;color:var(--text2);">Chrome 113+ ¬∑ Edge 113+ ¬∑ Firefox 141+ ¬∑ Safari 18+</p>
            <p style="margin-top:12px;font-size:12px;color:var(--text2);">If your browser supports WebGPU, try: close all tabs and reopen, or check <code style="color:var(--primary);">chrome://gpu</code> for WebGPU status.</p>
        </div>
    </div>
    <header class="header" id="mainHeader">
        <div class="logo">
            <svg viewBox="0 0 100 100" fill="none"><circle cx="50" cy="20" r="6" fill="#00ff88"/><circle cx="20" cy="50" r="6" fill="#0099ff"/><circle cx="80" cy="50" r="6" fill="#9966ff"/><circle cx="50" cy="80" r="6" fill="#00ff88"/><path d="M50 26L20 50M50 26L80 50M20 50L50 74M80 50L50 74" stroke="#00ff88" stroke-width="2" opacity="0.6"/><circle cx="50" cy="50" r="10" fill="#00ff88"/></svg>
            <span>NeuroConstellation<span style="font-weight:300;opacity:0.7;">Web</span></span>
            <span style="font-size:11px;padding:3px 10px;background:#00ff88;border-radius:10px;color:#000;margin-left:8px;font-weight:700;-webkit-text-fill-color:#000;-webkit-background-clip:border-box;">v1.0</span>
        </div>
        <div class="hstats">
            <div class="hstat"><div class="val" id="hNeurons">0</div><div class="lbl">Neurons</div></div>
            <div class="hstat"><div class="val" id="hSpikes">0</div><div class="lbl">Spikes</div></div>
            <div class="hstat"><div class="val" id="hActive">0</div><div class="lbl">Active</div></div>
            <div class="hstat"><div class="val" id="hMode">Spike</div><div class="lbl">Mode</div></div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
            <button class="btn btn-secondary" id="btnScreenshot" style="width:auto;padding:8px 14px;font-size:14px;border-radius:8px;" title="Screenshot (P)">üì∑</button>
            <button class="btn btn-secondary" id="btnRecord" style="width:auto;padding:8px 14px;font-size:14px;border-radius:8px;" title="Record (V)">‚è∫ Rec</button>
        </div>
    </header>
    <div class="cpanel" id="controlPanel">
        <div class="cpanel-head">
            <h3>Visualisation Controls</h3>
            <button id="cpanelToggle">‚ñ≤</button>
        </div>
        <div class="cpanel-body" id="cpanelBody">
            <div class="csection">
                <div class="csection-title">Dataset</div>
                <div class="citem">
                    <div class="citem-label"><span>Load Data</span></div>
                    <button class="btn btn-primary" id="btnLoadData" style="margin-bottom:8px;">Load Dataset (.bin / .json)</button>
                    <button class="btn btn-secondary" id="btnLoadSynthetic" style="margin-bottom:8px;">Load Synthetic (288K)</button>
                    <input type="file" id="fileInputData" accept=".bin,.dat,.json" style="display:none;">
                    <div id="datasetInfo" style="font-size:11px; color:var(--text2); line-height:1.6; margin-bottom:8px;">
                        No dataset loaded ‚Äî click above to load
                    </div>
                </div>
                <div class="citem">
                    <div class="citem-label"><span>Scale</span><span class="citem-val" id="dsLabel">100%</span></div>
                    <div class="dataset-btns">
                        <button class="ds-btn" data-pct="25">25%</button>
                        <button class="ds-btn" data-pct="50">50%</button>
                        <button class="ds-btn" data-pct="75">75%</button>
                        <button class="ds-btn active" data-pct="100">100%</button>
                    </div>
                </div>
            </div>
            <div class="csection">
                <div class="csection-title">Visualisation Mode (1-6)</div>
                <div class="mode-btns" style="margin-bottom:4px;">
                    <button class="mode-btn active" data-mode="spike" title="Mode 1: Ai(t) = max(0, 1‚àíŒît/w)">‚ö° Activity</button>
                    <button class="mode-btn" data-mode="static" title="Mode 2: 3-state recruitment logic">‚óâ Recruit</button>
                    <button class="mode-btn" data-mode="hybrid" title="Mode 3: Vi(t) = max(Ai(t), Ai(t+wp)√ó0.7)">üîÆ Preview</button>
                </div>
                <div class="mode-btns">
                    <button class="mode-btn" data-mode="recruit" title="Mode 4: Exponential decay œÑ=200ms">üî• Persist</button>
                    <button class="mode-btn" data-mode="heatmap" title="Mode 5: Log-normalised log‚ÇÇ(f+1)/log‚ÇÇ(201)">üìä Freq</button>
                    <button class="mode-btn" data-mode="frequency" title="Mode 6: 5 checkpoints at 0,5,10,20,40ms">üåä Trail</button>
                </div>
            </div>
            <div class="csection">
                <div class="csection-title">Display</div>
                <div class="citem">
                    <div class="citem-label"><span>Neuron Scale</span><span class="citem-val" id="scaleVal">1.0x</span></div>
                    <div class="slider-wrap" id="sliderScale" data-min="0.1" data-max="5" data-value="1" data-step="0.1">
                        <div class="slider-track"><div class="slider-fill"></div></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="citem">
                    <div class="toggle-row" id="togContainer">
                        <span>Wireframe Container</span>
                        <div class="toggle-track"><div class="toggle-knob"></div></div>
                    </div>
                </div>
                <div class="citem">
                    <div class="toggle-row" id="togRotate">
                        <span>Auto Rotate</span>
                        <div class="toggle-track"><div class="toggle-knob"></div></div>
                    </div>
                </div>
            </div>
            <div class="csection">
                <div class="csection-title">Neuron Colours</div>
                <div class="citem">
                    <div class="citem-label"><span>Inactive</span></div>
                    <div class="cpick-row">
                        <div class="cpick-swatch" id="swatchInactive" style="background:#3366ff;"></div>
                        <input type="color" class="cpick-input" id="pickInactive" value="#3366ff">
                        <span class="cpick-hex" id="hexInactive">#3366ff</span>
                    </div>
                </div>
                <div class="citem">
                    <div class="citem-label"><span>Active</span></div>
                    <div class="cpick-row">
                        <div class="cpick-swatch" id="swatchActive" style="background:#ff4d1a;"></div>
                        <input type="color" class="cpick-input" id="pickActive" value="#ff4d1a">
                        <span class="cpick-hex" id="hexActive">#ff4d1a</span>
                    </div>
                </div>
                <div class="citem">
                    <div class="citem-label"><span>Background</span></div>
                    <div class="cpick-row">
                        <div class="cpick-swatch" id="swatchBg" style="background:#030408;"></div>
                        <input type="color" class="cpick-input" id="pickBg" value="#030408">
                        <span class="cpick-hex" id="hexBg">#030408</span>
                    </div>
                </div>
            </div>
            <div class="csection">
                <div class="csection-title">Activity Playback</div>
                <div class="citem">
                    <div class="citem-label"><span>Speed</span><span class="citem-val" id="speedVal">1.0x</span></div>
                    <div class="slider-wrap" id="sliderSpeed" data-min="0.001" data-max="5" data-value="0.01" data-step="0.001">
                        <div class="slider-track"><div class="slider-fill"></div></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="citem">
                    <div class="citem-label"><span>Activation Window</span><span class="citem-val" id="windowVal">1.0 ms</span></div>
                    <div class="slider-wrap" id="sliderWindow" data-min="0.1" data-max="10" data-value="1" data-step="0.1">
                        <div class="slider-track"><div class="slider-fill"></div></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="timeline" id="timeline">
                    <div class="timeline-fill" id="tlFill"></div>
                    <div class="timeline-info">
                        <div class="timeline-time" id="tlTime">0.00 ms</div>
                        <div class="timeline-total">/ <span id="tlTotal">0 ms</span></div>
                    </div>
                </div>
                <button class="btn btn-secondary" id="btnPlayPause">‚è∏ Pause</button>
            </div>
            <div class="csection">
                <div class="csection-title">Camera</div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:4px;margin-bottom:8px;">
                    <button class="btn btn-secondary" onclick="window._app.setCameraPreset('front')" style="font-size:10px;padding:5px;">Front</button>
                    <button class="btn btn-secondary" onclick="window._app.setCameraPreset('top')" style="font-size:10px;padding:5px;">Top</button>
                    <button class="btn btn-secondary" onclick="window._app.setCameraPreset('side')" style="font-size:10px;padding:5px;">Side</button>
                    <button class="btn btn-secondary" onclick="window._app.setCameraPreset('angle')" style="font-size:10px;padding:5px;">45¬∞</button>
                    <button class="btn btn-secondary" onclick="window._app.setCameraPreset('back')" style="font-size:10px;padding:5px;">Back</button>
                    <button class="btn btn-primary" onclick="window._app.setCameraPreset('reset')" style="font-size:10px;padding:5px;">Reset</button>
                </div>
            </div>
        </div>
    </div>
    <div class="perfmon" id="perfMon">
        <h4>Performance</h4>
        <div class="pstat"><span class="plbl">FPS</span><span class="pval fps-hi" id="pFps">0</span></div>
        <div class="pstat"><span class="plbl">Frame</span><span class="pval" id="pFrame">0.0 ms</span></div>
        <div class="pstat"><span class="plbl">VRAM</span><span class="pval" id="pMem">0 MB</span></div>
        <div class="pstat"><span class="plbl">Neurons</span><span class="pval" id="pNeurons">0</span></div>
        <div class="pstat"><span class="plbl">Pipeline</span><span class="pval" id="pCompute">Billboard</span></div>
        <div class="pstat"><span class="plbl">GPU</span><span class="pval" id="pGPU" style="font-size:9px;">‚Äî</span></div>
    </div>
    <div class="infobar" id="infoBar">
        <div class="iitem" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">Drag: rotate ¬∑ Right: pan ¬∑ Scroll: zoom ¬∑ Space: play ¬∑ ‚Üë‚Üì: speed ¬∑ ‚Üê‚Üí: seek ¬∑ W/S: window ¬∑ Q/E: scale ¬∑ 1-6: mode ¬∑ P: capture ¬∑ V: record ¬∑ M: map ¬∑ T: rotate ¬∑ G: box ¬∑ F: full ¬∑ H: hide ¬∑ C: panel ¬∑ R: reset</div>
    </div>
    <button class="fab" id="fabToggle" title="Toggle UI (H)">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
    </button>
    <div id="recBadge" style="position:fixed;top:60px;left:50%;transform:translateX(-50%);padding:6px 18px;background:rgba(255,0,0,0.15);border:1px solid rgba(255,0,0,0.3);border-radius:20px;color:#ff4444;font-size:12px;font-weight:700;z-index:200;align-items:center;gap:8px;">
        <div style="width:8px;height:8px;border-radius:50%;background:#ff4444;animation:recBlink 1s infinite;"></div>
        <span id="recTimer">REC 00:00</span>
    </div>
    <div id="minimapPanel" style="position:absolute;top:255px;right:28px;z-index:99;width:170px;height:160px;border-radius:10px;border:1px solid rgba(255,255,255,0.08);overflow:hidden;background:rgba(5,5,8,0.9);">
        <canvas id="minimapCanvas" width="340" height="320" style="width:100%;height:100%;display:block;"></canvas>
        <div style="position:absolute;bottom:3px;left:0;right:0;text-align:center;font-size:9px;color:rgba(255,255,255,0.2);font-weight:600;letter-spacing:0.5px;">TOP VIEW</div>
    </div>
<script>
const COMPUTE_SHADER_WGSL = /* wgsl */`
struct Params {
    neuronCount: u32,          // offset 0
    maxSpikesPerNeuron: u32,   // offset 4
    currentTime: f32,          // offset 8
    activationWindow: f32,     // offset 12
    inactiveColor: vec4f,      // offset 16 (vec4 aligned to 16)
    activeColor: vec4f,        // offset 32
    mode: u32,                 // offset 48
    maxSpikeCount: u32,        // offset 52
    deltaTime: f32,            // offset 56 ‚Äî frame dt in seconds
    totalDuration: f32,        // offset 60 ‚Äî total simulation time ms
    gradLow: vec4f,            // offset 64
    gradMid: vec4f,            // offset 80
    gradHigh: vec4f,           // offset 96
    gradMax: vec4f,            // offset 112
};
@group(0) @binding(0) var<uniform> params: Params;
@group(0) @binding(1) var<storage, read> spikeTimes: array<f32>;
@group(0) @binding(2) var<storage, read> spikeCounts: array<i32>;
@group(0) @binding(3) var<storage, read_write> activations: array<vec4f>;
@group(0) @binding(4) var<storage, read_write> modeData: array<f32>; // persistent per-neuron data
fn calcGradient(rawT: f32) -> vec3f {
    let t = pow(rawT, 0.35);
    if (t < 0.25) { return mix(params.gradLow.rgb, params.gradMid.rgb, t * 4.0); }
    else if (t < 0.6) { return mix(params.gradMid.rgb, params.gradHigh.rgb, (t - 0.25) / 0.35); }
    else { return mix(params.gradHigh.rgb, params.gradMax.rgb, (t - 0.6) / 0.4); }
}
fn calcFreqGradient(t: f32) -> vec3f {
    if (t < 0.25) { return mix(vec3f(0.05, 0.1, 0.6), vec3f(0.0, 0.7, 0.9), t * 4.0); }
    else if (t < 0.5) { return mix(vec3f(0.0, 0.7, 0.9), vec3f(0.0, 0.85, 0.2), (t - 0.25) * 4.0); }
    else if (t < 0.75) { return mix(vec3f(0.0, 0.85, 0.2), vec3f(1.0, 0.9, 0.0), (t - 0.5) * 4.0); }
    else { return mix(vec3f(1.0, 0.9, 0.0), vec3f(1.0, 0.15, 0.0), (t - 0.75) * 4.0); }
}
fn checkActivation(neuronId: u32) -> f32 {
    let sc = spikeCounts[neuronId];
    if (sc == 0) { return 0.0; }
    let baseIndex = neuronId * params.maxSpikesPerNeuron;
    var minDiff: f32 = 1e30;
    let count = min(u32(sc), params.maxSpikesPerNeuron);
    for (var i: u32 = 0u; i < count; i++) {
        let st = spikeTimes[baseIndex + i];
        if (st >= 1e30) { break; }
        let d = abs(st - params.currentTime);
        if (d < minDiff) { minDiff = d; }
        if (minDiff < params.activationWindow) { break; }
    }
    if (minDiff < params.activationWindow) { return 1.0 - (minDiff / params.activationWindow); }
    return 0.0;
}
fn checkFutureActivation(neuronId: u32, offset: f32) -> f32 {
    let sc = spikeCounts[neuronId];
    if (sc == 0) { return 0.0; }
    let baseIndex = neuronId * params.maxSpikesPerNeuron;
    let futureTime = params.currentTime + offset;
    var minDiff: f32 = 1e30;
    let count = min(u32(sc), params.maxSpikesPerNeuron);
    for (var i: u32 = 0u; i < count; i++) {
        let st = spikeTimes[baseIndex + i];
        if (st >= 1e30) { break; }
        let d = abs(st - futureTime);
        if (d < minDiff) { minDiff = d; }
        if (minDiff < params.activationWindow) { break; }
    }
    if (minDiff < params.activationWindow) { return 1.0 - (minDiff / params.activationWindow); }
    return 0.0;
}
fn checkAtOffset(baseIndex: u32, count: u32, offset: f32) -> f32 {
    let checkTime = params.currentTime - offset;
    if (checkTime < 0.0) { return 0.0; }
    for (var i: u32 = 0u; i < count; i++) {
        let st = spikeTimes[baseIndex + i];
        if (st >= 1e30) { return 0.0; }
        if (abs(st - checkTime) < params.activationWindow) { return 1.0; }
    }
    return 0.0;
}
fn calcSpikeTrail(neuronId: u32) -> f32 {
    let sc = spikeCounts[neuronId];
    if (sc == 0) { return 0.0; }
    let baseIndex = neuronId * params.maxSpikesPerNeuron;
    let count = min(u32(sc), params.maxSpikesPerNeuron);
    var trail: f32 = 0.0;
    trail += checkAtOffset(baseIndex, count, 0.0) * 1.0;
    trail += checkAtOffset(baseIndex, count, 5.0) * 0.7;
    trail += checkAtOffset(baseIndex, count, 10.0) * 0.45;
    trail += checkAtOffset(baseIndex, count, 20.0) * 0.25;
    trail += checkAtOffset(baseIndex, count, 40.0) * 0.1;
    return clamp(trail, 0.0, 1.0);
}
@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3u) {
    let nid = gid.x;
    if (nid >= params.neuronCount) { return; }
    var activity: f32;
    var color: vec3f;
    if (params.mode == 0u) {
        let act = checkActivation(nid);
        activity = act;
        color = mix(params.inactiveColor.rgb, params.activeColor.rgb, act);
    } else if (params.mode == 1u) {
        let sc = spikeCounts[nid];
        let currentAct = checkActivation(nid);
        if (currentAct > 0.1) {
            activity = 1.0;
            color = params.activeColor.rgb;
        } else if (sc > 0) {
            activity = 0.5;
            color = mix(params.inactiveColor.rgb, params.activeColor.rgb, 0.5);
        } else {
            activity = 0.0;
            color = params.inactiveColor.rgb * 0.3;
        }
    } else if (params.mode == 2u) {
        let currentAct = checkActivation(nid);
        let futureAct = checkFutureActivation(nid, 5.0);
        let previewStrength = max(currentAct, futureAct * 0.7);
        activity = previewStrength;
        let previewColor = vec3f(0.2, 0.5, 1.0);
        if (currentAct > futureAct * 0.7) {
            color = mix(params.inactiveColor.rgb, params.activeColor.rgb, currentAct);
        } else {
            color = mix(params.inactiveColor.rgb, previewColor, futureAct * 0.7);
        }
    } else if (params.mode == 3u) {
        let act = checkActivation(nid);
        var heat = modeData[nid];
        let tau = 0.2; // 200ms (thesis Fig.19d)
        let decay = exp(-params.deltaTime / tau);
        heat = heat * decay + act;
        heat = min(heat, 3.0);
        modeData[nid] = heat;
        let normHeat = clamp(heat / 2.0, 0.0, 1.0);
        activity = normHeat;
        color = calcFreqGradient(normHeat);
    } else if (params.mode == 4u) {
        let sc = spikeCounts[nid];
        let dur = max(params.totalDuration, 1.0);
        let freq = f32(sc) / (dur * 0.001);
        let logFreq = log2(freq + 1.0) / log2(201.0);
        let t = clamp(logFreq, 0.0, 1.0);
        activity = 0.0;
        color = calcFreqGradient(t);
    } else if (params.mode == 5u) {
        let trail = calcSpikeTrail(nid);
        activity = trail;
        color = mix(vec3f(0.08, 0.03, 0.01), vec3f(1.0, 0.6, 0.1), trail);
    } else {
        activity = 0.0;
        color = params.inactiveColor.rgb;
    }
    activations[nid] = vec4f(activity, color.r, color.g, color.b);
}
`;
const RENDER_SHADER_WGSL = /* wgsl */`
struct Camera {
    viewProj: mat4x4f,       // offset 0, size 64
    model: mat4x4f,          // offset 64, size 64
    cameraPosAndSize: vec4f,  // offset 128: xyz=cameraPos, w=pointSize
    sizesAndPad: vec4f,       // offset 144: x=inactiveSize, y=activeSize, zw=pad
    lightDirAndPad: vec4f,    // offset 160: xyz=lightDir, w=pad
};
@group(0) @binding(0) var<uniform> cam: Camera;
@group(0) @binding(1) var<storage, read> positions: array<f32>; // packed XYZ (12 bytes per neuron)
@group(0) @binding(2) var<storage, read> activations: array<vec4f>;
struct VSOut {
    @builtin(position) pos: vec4f,
    @location(0) color: vec3f,
    @location(1) normal: vec3f,
    @location(2) worldPos: vec3f,
};
@vertex
fn vsMain(
    @location(0) localPos: vec3f,
    @location(1) localNorm: vec3f,
    @builtin(instance_index) iid: u32,
) -> VSOut {
    var o: VSOut;
    let act = activations[iid]; // (activity, r, g, b)
    let activity = act.x;
    let color = act.yzw;
    let inactiveSize = cam.sizesAndPad.x;
    let activeSize = cam.sizesAndPad.y;
    let pointSize = cam.cameraPosAndSize.w;
    let sizeMul = mix(inactiveSize, activeSize, activity);
    let finalSize = pointSize * sizeMul;
    let scaled = localPos * finalSize;
    let neuronPos = vec3f(positions[iid*3u], positions[iid*3u+1u], positions[iid*3u+2u]);
    let transformed = (cam.model * vec4f(neuronPos, 1.0)).xyz;
    let worldPos = transformed + scaled;
    o.pos = cam.viewProj * vec4f(worldPos, 1.0);
    o.color = color;
    o.normal = localNorm;
    o.worldPos = worldPos;
    return o;
}
@fragment
fn fsMain(inp: VSOut) -> @location(0) vec4f {
    let n = normalize(inp.normal);
    let l = normalize(cam.lightDirAndPad.xyz);
    let ndotl = max(dot(n, l), 0.0);
    let diffuse = ndotl * 0.7 + 0.3;
    var c = inp.color * diffuse;
    let v = normalize(cam.cameraPosAndSize.xyz - inp.worldPos);
    let h = normalize(l + v);
    let spec = pow(max(dot(n, h), 0.0), 32.0) * 0.3;
    c += vec3f(spec);
    return vec4f(c, 1.0);
}
`;
const POINT_SHADER_WGSL = /* wgsl */`
struct Camera {
    viewProj: mat4x4f,
    model: mat4x4f,
    cameraPosAndSize: vec4f,
    sizesAndPad: vec4f,
    lightDirAndPad: vec4f,
};
@group(0) @binding(0) var<uniform> cam: Camera;
@group(0) @binding(1) var<storage, read> positions: array<f32>; // packed XYZ (12 bytes per neuron)
@group(0) @binding(2) var<storage, read> activations: array<vec4f>;
struct VSOut {
    @builtin(position) pos: vec4f,
    @location(0) color: vec3f,
    @location(1) uv: vec2f,
    @location(2) depth: f32,
};
const QUAD_UV = array<vec2f, 6>(
    vec2f(-1.0, -1.0), vec2f(1.0, -1.0), vec2f(1.0, 1.0),
    vec2f(-1.0, -1.0), vec2f(1.0, 1.0), vec2f(-1.0, 1.0),
);
@vertex
fn vsPoint(
    @builtin(vertex_index) vid: u32,
    @builtin(instance_index) iid: u32,
) -> VSOut {
    var o: VSOut;
    let act = activations[iid];
    let activity = act.x;
    let neuronPos = vec3f(positions[iid*3u], positions[iid*3u+1u], positions[iid*3u+2u]);
    let worldPos = (cam.model * vec4f(neuronPos, 1.0)).xyz;
    let corner = QUAD_UV[vid];
    let camPos = cam.cameraPosAndSize.xyz;
    let toCamera = normalize(camPos - worldPos);
    let right = normalize(cross(toCamera, vec3f(0.0, 1.0, 0.0)));
    let up = cross(right, toCamera);
    let inactiveSize = cam.sizesAndPad.x;
    let activeSize = cam.sizesAndPad.y;
    let baseSize = cam.cameraPosAndSize.w;
    let sizeMul = mix(inactiveSize, activeSize, activity);
    let dist = length(camPos - worldPos);
    let distScale = clamp(4.0 / max(dist, 0.1), 0.3, 2.0);
    let quadSize = baseSize * sizeMul * distScale;
    let offset = right * corner.x * quadSize + up * corner.y * quadSize;
    let finalPos = worldPos + offset;
    o.pos = cam.viewProj * vec4f(finalPos, 1.0);
    o.color = act.yzw;
    o.uv = corner;
    o.depth = length(camPos - worldPos);
    return o;
}
@fragment
fn fsPoint(inp: VSOut) -> @location(0) vec4f {
    let d = length(inp.uv);
    if (d > 1.0) { discard; }
    let glow = exp(-d * d * 3.0);
    let rim = smoothstep(1.0, 0.6, d) * 0.3;
    let depthNorm = clamp((inp.depth - 1.5) * 0.1, 0.0, 1.0);
    let fogColor = vec3f(0.02, 0.04, 0.12);
    let depthFade = 1.0 - depthNorm * 0.85;
    let baseColor = inp.color;
    let brightness = max(baseColor.r, max(baseColor.g, baseColor.b));
    let isActive = step(0.3, brightness);
    let bloomBoost = 1.0 + isActive * 2.5;
    let saturated = mix(vec3f(dot(baseColor, vec3f(0.299, 0.587, 0.114))), baseColor, 1.0 + isActive * 0.5);
    var c = saturated * glow * bloomBoost * depthFade;
    c += vec3f(rim * depthFade * 0.5); // subtle rim light
    c = mix(c, fogColor, depthNorm * 0.6); // atmospheric fog blend
    c = c / (c + vec3f(0.8)); // Reinhard tonemap
    c = pow(c, vec3f(0.9)); // slight gamma for punch
    return vec4f(c, 1.0);
}
`;
const WIREFRAME_SHADER_WGSL = /* wgsl */`
struct WireCam {
    viewProj: mat4x4f,
    model: mat4x4f,
    color: vec4f,
};
@group(0) @binding(0) var<uniform> wcam: WireCam;
@vertex
fn vsWire(@location(0) pos: vec3f) -> @builtin(position) vec4f {
    let world = (wcam.model * vec4f(pos, 1.0)).xyz;
    return wcam.viewProj * vec4f(world, 1.0);
}
@fragment
fn fsWire() -> @location(0) vec4f {
    return wcam.color;
}
`;
function generateIcosahedron() {
    const t = (1 + Math.sqrt(5)) / 2;
    const raw = [
        [-1,t,0],[1,t,0],[-1,-t,0],[1,-t,0],
        [0,-1,t],[0,1,t],[0,-1,-t],[0,1,-t],
        [t,0,-1],[t,0,1],[-t,0,-1],[-t,0,1]
    ];
    const verts = raw.map(v => { const l = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return [v[0]/l, v[1]/l, v[2]/l]; });
    const tris = [
        0,11,5, 0,5,1, 0,1,7, 0,7,10, 0,10,11,
        1,5,9, 5,11,4, 11,10,2, 10,7,6, 7,1,8,
        3,9,4, 3,4,2, 3,2,6, 3,6,8, 3,8,9,
        4,9,5, 2,4,11, 6,2,10, 8,6,7, 9,8,1
    ];
    return subdivideSphere(verts, tris, 1);
}
function subdivideSphere(verts, tris, levels) {
    let v = verts.slice(), t = tris.slice();
    for (let l = 0; l < levels; l++) {
        const cache = {};
        const newT = [];
        const midpoint = (a, b) => {
            const key = Math.min(a,b) + '_' + Math.max(a,b);
            if (cache[key] !== undefined) return cache[key];
            const mx = (v[a][0]+v[b][0])/2, my = (v[a][1]+v[b][1])/2, mz = (v[a][2]+v[b][2])/2;
            const len = Math.sqrt(mx*mx+my*my+mz*mz);
            v.push([mx/len, my/len, mz/len]);
            cache[key] = v.length - 1;
            return cache[key];
        };
        for (let i = 0; i < t.length; i += 3) {
            const a = t[i], b = t[i+1], c = t[i+2];
            const m0 = midpoint(a,b), m1 = midpoint(b,c), m2 = midpoint(c,a);
            newT.push(a,m0,m2, b,m1,m0, c,m2,m1, m0,m1,m2);
        }
        t = newT;
    }
    const positions = new Float32Array(v.length * 3);
    const normals = new Float32Array(v.length * 3);
    for (let i = 0; i < v.length; i++) {
        positions[i*3] = v[i][0]; positions[i*3+1] = v[i][1]; positions[i*3+2] = v[i][2];
        normals[i*3] = v[i][0]; normals[i*3+1] = v[i][1]; normals[i*3+2] = v[i][2];
    }
    return { positions, normals, indices: new Uint16Array(t), vertexCount: v.length, indexCount: t.length };
}
function generateWireframeBox(halfSize) {
    const s = halfSize;
    const corners = [
        [-s,-s,-s],[s,-s,-s],[s,-s,s],[-s,-s,s],
        [-s,s,-s],[s,s,-s],[s,s,s],[-s,s,s]
    ];
    const edges = [
        0,1, 1,2, 2,3, 3,0,  // bottom
        4,5, 5,6, 6,7, 7,4,  // top
        0,4, 1,5, 2,6, 3,7   // verticals
    ];
    const verts = new Float32Array(edges.length * 3);
    for (let i = 0; i < edges.length; i++) {
        const c = corners[edges[i]];
        verts[i*3] = c[0]; verts[i*3+1] = c[1]; verts[i*3+2] = c[2];
    }
    return { positions: verts, vertexCount: edges.length };
}
const mat4 = {
    create: () => new Float32Array(16),
    identity: (o) => { o.fill(0); o[0]=o[5]=o[10]=o[15]=1; return o; },
    perspective: (o, fov, aspect, near, far) => {
        const f = 1/Math.tan(fov/2), nf = 1/(near-far);
        o.fill(0); o[0]=f/aspect; o[5]=f; o[10]=(far+near)*nf; o[11]=-1; o[14]=2*far*near*nf;
        return o;
    },
    lookAt: (o, eye, center, up) => {
        let fx=center[0]-eye[0], fy=center[1]-eye[1], fz=center[2]-eye[2];
        let len=Math.sqrt(fx*fx+fy*fy+fz*fz); fx/=len; fy/=len; fz/=len;
        let sx=fy*up[2]-fz*up[1], sy=fz*up[0]-fx*up[2], sz=fx*up[1]-fy*up[0];
        len=Math.sqrt(sx*sx+sy*sy+sz*sz); sx/=len; sy/=len; sz/=len;
        const ux=sy*fz-sz*fy, uy=sz*fx-sx*fz, uz=sx*fy-sy*fx;
        o[0]=sx;o[1]=ux;o[2]=-fx;o[3]=0;
        o[4]=sy;o[5]=uy;o[6]=-fy;o[7]=0;
        o[8]=sz;o[9]=uz;o[10]=-fz;o[11]=0;
        o[12]=-(sx*eye[0]+sy*eye[1]+sz*eye[2]);
        o[13]=-(ux*eye[0]+uy*eye[1]+uz*eye[2]);
        o[14]=(fx*eye[0]+fy*eye[1]+fz*eye[2]);
        o[15]=1;
        return o;
    },
    multiply: (o, a, b) => {
        for (let i=0;i<4;i++) for (let j=0;j<4;j++) {
            o[j*4+i]=a[i]*b[j*4]+a[4+i]*b[j*4+1]+a[8+i]*b[j*4+2]+a[12+i]*b[j*4+3];
        }
        return o;
    },
    rotateY: (o, a, rad) => {
        const s=Math.sin(rad),c=Math.cos(rad),
        a00=a[0],a01=a[1],a02=a[2],a03=a[3],
        a20=a[8],a21=a[9],a22=a[10],a23=a[11];
        for(let i=0;i<16;i++) o[i]=a[i];
        o[0]=a00*c+a20*s; o[1]=a01*c+a21*s; o[2]=a02*c+a22*s; o[3]=a03*c+a23*s;
        o[8]=a20*c-a00*s; o[9]=a21*c-a01*s; o[10]=a22*c-a02*s; o[11]=a23*c-a03*s;
        return o;
    },
    rotateX: (o, a, rad) => {
        const s=Math.sin(rad),c=Math.cos(rad),
        a10=a[4],a11=a[5],a12=a[6],a13=a[7],
        a20=a[8],a21=a[9],a22=a[10],a23=a[11];
        for(let i=0;i<16;i++) o[i]=a[i];
        o[4]=a10*c+a20*s; o[5]=a11*c+a21*s; o[6]=a12*c+a22*s; o[7]=a13*c+a23*s;
        o[8]=a20*c-a10*s; o[9]=a21*c-a11*s; o[10]=a22*c-a12*s; o[11]=a23*c-a13*s;
        return o;
    },
};
function generateSyntheticData(neuronCount, pctActive = 0.35) {
    const positions = new Float32Array(neuronCount * 3);
    const xRange = 2000, yRange = 4000, zRange = 2000;
    for (let i = 0; i < neuronCount; i++) {
        const t = i / neuronCount;
        const angle = t * Math.PI * 1.5;
        const r = 1500 + Math.random() * 800;
        const x = r * Math.cos(angle) + (Math.random() - 0.5) * 400;
        const y = t * yRange + (Math.random() - 0.5) * 300;
        const z = r * Math.sin(angle) + (Math.random() - 0.5) * 400;
        positions[i * 3]     = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
    }
    const activeNeurons = Math.floor(neuronCount * pctActive);
    const maxSpikesPerNeuron = 82; // Matches thesis Table 23
    const totalSpikeSlots = neuronCount * maxSpikesPerNeuron;
    const spikeTimes = new Float32Array(totalSpikeSlots);
    const spikeCounts = new Int32Array(neuronCount);
    spikeTimes.fill(3.4028235e+38);
    const minTime = 0.0;
    const maxTime = 995.2; // ms ‚Äî matches thesis spike event duration
    let totalSpikes = 0;
    for (let i = 0; i < neuronCount; i++) {
        if (Math.random() > pctActive) continue;
        const nSpikes = Math.floor(Math.random() * maxSpikesPerNeuron * 0.8) + 1;
        const clampedSpikes = Math.min(nSpikes, maxSpikesPerNeuron);
        spikeCounts[i] = clampedSpikes;
        totalSpikes += clampedSpikes;
        const baseIdx = i * maxSpikesPerNeuron;
        const times = [];
        for (let s = 0; s < clampedSpikes; s++) {
            times.push(minTime + Math.random() * (maxTime - minTime));
        }
        times.sort((a, b) => a - b);
        for (let s = 0; s < clampedSpikes; s++) {
            spikeTimes[baseIdx + s] = times[s];
        }
    }
    let maxSC = 0;
    for (let i = 0; i < neuronCount; i++) {
        if (spikeCounts[i] > maxSC) maxSC = spikeCounts[i];
    }
    return { positions, spikeTimes, spikeCounts, maxSpikesPerNeuron, minTime, maxTime, totalSpikes, maxSpikeCount: maxSC };
}
class NeuroConstellationWeb {
    constructor() {
        this.config = {
            mode: 0,  // 0=Real-Time Activity, 1=Recruitment Map, 2=Forward Preview, 3=Activity Persistence, 4=Firing Rate Map, 5=Spike History Trail
            neuronScale: 1.0,
            pointSize: 0.01,
            inactiveSize: 1.0,
            activeSize: 2.0,
            playbackSpeed: 0.01,
            activationWindow: 1.0,
            showContainer: false,
            autoRotate: false,
            datasetPct: 100,
            inactiveColor: [0.15, 0.35, 1.0, 1.0],   // deep electric blue
            activeColor:   [1.0, 0.25, 0.05, 1.0],    // hot orange-red
            bgColor:       [0.01, 0.015, 0.04],        // background
            gradLow:  [0.1, 0.15, 0.9, 1.0],    // deep blue
            gradMid:  [0.0, 0.9, 1.0, 1.0],     // electric cyan
            gradHigh: [1.0, 0.9, 0.0, 1.0],     // bright yellow
            gradMax:  [1.0, 0.15, 0.0, 1.0],    // hot red
        };
        this.camera = {
            distance: 8,
            rotX: 0.5,   // pitch
            rotY: 0,     // yaw
            panX: 0, panY: 0,
            fov: 75 * Math.PI / 180,
        };
        this._ct = 0;
        this.minTime = 0;
        this.maxTime = 1000;
        this._ip = true;
        this._lft = 0;
        this._mry = 0;
        this.device = null;
        this.ctx = null;
        this.data = null;
        this._nc = 0;
        this._np = null;
        this._ir = false;
        this._mr = null;
        this._rc = [];
        this._rst = 0;
        this.fps = 0;
        this._fc = 0;
        this._fpt = 0;
        this._uv = true;
        this.setupIntro();
    }
    setupIntro() {
        document.getElementById('enterBtn').addEventListener('click', () => {
            document.getElementById('introOverlay').classList.add('hidden');
            setTimeout(() => {
                document.getElementById('introOverlay').style.display = 'none';
                this.startInit();
            }, 800);
        });
    }
    async startInit() {
        const loading = document.getElementById('loadingOverlay');
        loading.classList.add('visible');
        try {
            await this.initWebGPU();
        } catch(e) {
            this.showError(e.message);
        }
    }
    showError(msg) {
        document.getElementById('loadingOverlay').classList.remove('visible');
        const overlay = document.getElementById('errorOverlay');
        overlay.classList.add('visible');
        const errBox = overlay.querySelector('.err-msg') || overlay.querySelector('p');
        if (errBox) errBox.textContent = msg;
    }
    setProgress(pct, status) {
        document.getElementById('progressFill').style.width = pct + '%';
        document.getElementById('loadingStatus').textContent = status;
    }
    async initWebGPU() {
        if (!navigator.gpu) {
            throw new Error('WebGPU not supported in this browser');
        }
        this.setProgress(10, 'Requesting GPU adapter...');
        let adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
        if (!adapter) {
            adapter = await navigator.gpu.requestAdapter();
        }
        if (!adapter) throw new Error('No GPU adapter found ‚Äî your browser may not support WebGPU');
        const gpuInfo = adapter.info || {};
        this._gn = gpuInfo.description || gpuInfo.architecture || gpuInfo.vendor || 'WebGPU';
        const gpuEl = document.getElementById('pGPU');
        if (gpuEl) gpuEl.textContent = this._gn;
        this.setProgress(20, 'Requesting GPU device...');
        this.device = await adapter.requestDevice({
            requiredLimits: {
                maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
                maxBufferSize: adapter.limits.maxBufferSize,
            }
        });
        const canvas = document.getElementById('gpuCanvas');
        canvas.width = window.innerWidth * devicePixelRatio;
        canvas.height = window.innerHeight * devicePixelRatio;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        this.ctx = canvas.getContext('webgpu');
        this._pf = navigator.gpu.getPreferredCanvasFormat();
        this.ctx.configure({
            device: this.device,
            format: this._pf,
            alphaMode: 'opaque',
        });
        this.canvas = canvas;
        this.setProgress(30, 'Creating depth buffer...');
        this.createDepthTexture();
        this.setProgress(40, 'Initialising...');
        this._dl = false;
        this._nc = 0;
        this.minTime = 0;
        this.maxTime = 1000;
        this._ct = 0;
        this.setProgress(60, 'Compiling WGSL shaders...');
        await this.createPipelines();
        this.setProgress(75, 'Generating icosahedron mesh...');
        this.createGeometry();
        this.setProgress(80, 'Building wireframe container...');
        this.createWireframe();
        this.setProgress(90, 'Setting up controls...');
        this.setupControls();
        this.setProgress(95, 'Finalising...');
        this.updateHeaderStats();
        document.getElementById('tlTotal').textContent = '‚Äî';
        this.setProgress(100, 'Ready ‚Äî load a dataset to begin');
        document.getElementById('loadingSub').textContent = 'WebGPU initialised successfully';
        setTimeout(() => {
            const lo = document.getElementById('loadingOverlay');
            lo.classList.add('fade');
            setTimeout(() => { lo.classList.remove('visible'); lo.classList.remove('fade'); }, 500);
        }, 400);
        this._lft = performance.now();
        this._fpt = performance.now();
        requestAnimationFrame((t) => this.frame(t));
    }
    createDepthTexture() {
        if (this._dt) this._dt.destroy();
        this._dt = this.device.createTexture({
            size: [this.canvas.width, this.canvas.height],
            format: 'depth24plus',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
        this._dv = this._dt.createView();
    }
    createBuffers() {
        const d = this.device;
        const n = this._nc;
        const normPos = new Float32Array(n * 3);
        let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity,minZ=Infinity,maxZ=-Infinity;
        for (let i=0;i<n;i++) {
            const x=this.data.positions[i*3], y=this.data.positions[i*3+1], z=this.data.positions[i*3+2];
            if(x<minX)minX=x; if(x>maxX)maxX=x;
            if(y<minY)minY=y; if(y>maxY)maxY=y;
            if(z<minZ)minZ=z; if(z>maxZ)maxZ=z;
        }
        const cx=(minX+maxX)/2, cy=(minY+maxY)/2, cz=(minZ+maxZ)/2;
        const range = Math.max(maxX-minX, maxY-minY, maxZ-minZ);
        const scale = range > 0 ? 3.5 / range : 1;
        for (let i=0;i<n;i++) {
            normPos[i*3]   = (this.data.positions[i*3]   - cx) * scale;
            normPos[i*3+1] = (this.data.positions[i*3+1] - cy) * scale;
            normPos[i*3+2] = (this.data.positions[i*3+2] - cz) * scale;
        }
        const vol = (maxX-minX) * (maxY-minY) * (maxZ-minZ) * scale * scale * scale;
        const avgSpacing = Math.pow(vol / Math.max(1, n), 1/3);
        this.config.pointSize = avgSpacing * 0.25; // 25% of average spacing
        let nMinX=Infinity,nMaxX=-Infinity,nMinY=Infinity,nMaxY=-Infinity,nMinZ=Infinity,nMaxZ=-Infinity;
        for (let i=0;i<n;i++){
            const x=normPos[i*3],y=normPos[i*3+1],z=normPos[i*3+2];
            if(x<nMinX)nMinX=x;if(x>nMaxX)nMaxX=x;
            if(y<nMinY)nMinY=y;if(y>nMaxY)nMaxY=y;
            if(z<nMinZ)nMinZ=z;if(z>nMaxZ)nMaxZ=z;
        }
        document.getElementById('scaleVal').textContent = '1.0x';
        this.positionBuffer = d.createBuffer({
            size: normPos.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Float32Array(this.positionBuffer.getMappedRange()).set(normPos);
        this.positionBuffer.unmap();
        this._np = normPos; // Store for minimap
        const stSize = this.data.spikeTimes.byteLength;
        const maxBufSize = d.limits.maxStorageBufferBindingSize;
        if (stSize > maxBufSize) {
            const maxAllowedSpikes = Math.floor(maxBufSize / (n * 4));
            this.data.maxSpikesPerNeuron = Math.max(1, maxAllowedSpikes);
            const reduced = new Float32Array(n * this.data.maxSpikesPerNeuron);
            reduced.fill(3.4028235e+38);
            const oldMax = this.data.spikeTimes.length / n;
            for (let i = 0; i < n; i++) {
                const count = Math.min(this.data.spikeCounts[i], this.data.maxSpikesPerNeuron);
                this.data.spikeCounts[i] = count;
                for (let s = 0; s < count; s++) {
                    reduced[i * this.data.maxSpikesPerNeuron + s] = this.data.spikeTimes[i * oldMax + s];
                }
            }
            this.data.spikeTimes = reduced;
        }
        this.spikeTimesBuffer = d.createBuffer({
            size: this.data.spikeTimes.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Float32Array(this.spikeTimesBuffer.getMappedRange()).set(this.data.spikeTimes);
        this.spikeTimesBuffer.unmap();
        this.spikeCountsBuffer = d.createBuffer({
            size: this.data.spikeCounts.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Int32Array(this.spikeCountsBuffer.getMappedRange()).set(this.data.spikeCounts);
        this.spikeCountsBuffer.unmap();
        this.activationBuffer = d.createBuffer({
            size: n * 16, usage: GPUBufferUsage.STORAGE,
        });
        this.modeDataBuffer = d.createBuffer({
            size: n * 4, usage: GPUBufferUsage.STORAGE,
        });
        const totalBytes = normPos.byteLength + this.data.spikeTimes.byteLength +
            this.data.spikeCounts.byteLength + n * 16 + n * 4;
        this._gm = totalBytes / (1024*1024);
    }
    async createPipelines() {
        const d = this.device;
        this.computeUniformSize = 128;
        this.computeUniformBuffer = d.createBuffer({
            size: this.computeUniformSize, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.renderUniformSize = 176;
        this.renderUniformBuffer = d.createBuffer({
            size: this.renderUniformSize, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.wireUniformSize = 144;
        this.wireUniformBuffer = d.createBuffer({
            size: this.wireUniformSize, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const computeModule = d.createShaderModule({ code: COMPUTE_SHADER_WGSL });
        const computeInfo = await computeModule.getCompilationInfo();
        for (const msg of computeInfo.messages) {
            if (msg.type === 'error') {
                throw new Error(`WGSL Compute Error: ${msg.message} (line ${msg.lineNum})`);
            }
        }
        this.computeBGL = d.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
            ]
        });
        this.computePipeline = d.createComputePipeline({
            layout: d.createPipelineLayout({ bindGroupLayouts: [this.computeBGL] }),
            compute: { module: computeModule, entryPoint: 'main' },
        });
        const renderModule = d.createShaderModule({ code: RENDER_SHADER_WGSL });
        this.renderBGL = d.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                { binding: 1, visibility: GPUShaderStage.VERTEX, buffer: { type: 'read-only-storage' } },
                { binding: 2, visibility: GPUShaderStage.VERTEX, buffer: { type: 'read-only-storage' } },
            ]
        });
        this.renderPipeline = d.createRenderPipeline({
            layout: d.createPipelineLayout({ bindGroupLayouts: [this.renderBGL] }),
            vertex: {
                module: renderModule, entryPoint: 'vsMain',
                buffers: [
                    { arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] },
                    { arrayStride: 12, attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x3' }] },
                ],
            },
            fragment: {
                module: renderModule, entryPoint: 'fsMain',
                targets: [{ format: this._pf }],
            },
            primitive: { topology: 'triangle-list', cullMode: 'back' },
            depthStencil: { format: 'depth24plus', depthWriteEnabled: true, depthCompare: 'less' },
        });
        const wireModule = d.createShaderModule({ code: WIREFRAME_SHADER_WGSL });
        const pointModule = d.createShaderModule({ code: POINT_SHADER_WGSL });
        this.pointPipeline = d.createRenderPipeline({
            layout: d.createPipelineLayout({ bindGroupLayouts: [this.renderBGL] }),
            vertex: {
                module: pointModule, entryPoint: 'vsPoint',
                buffers: [],
            },
            fragment: {
                module: pointModule, entryPoint: 'fsPoint',
                targets: [{ format: this._pf }],
            },
            primitive: { topology: 'triangle-list' },
            depthStencil: { format: 'depth24plus', depthWriteEnabled: true, depthCompare: 'less' },
        });
        this.wireBGL = d.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
            ]
        });
        this.wirePipeline = d.createRenderPipeline({
            layout: d.createPipelineLayout({ bindGroupLayouts: [this.wireBGL] }),
            vertex: {
                module: wireModule, entryPoint: 'vsWire',
                buffers: [{ arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] }],
            },
            fragment: {
                module: wireModule, entryPoint: 'fsWire',
                targets: [{ format: this._pf, blend: {
                    color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha' },
                    alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha' },
                }}],
            },
            primitive: { topology: 'line-list' },
            depthStencil: { format: 'depth24plus', depthWriteEnabled: false, depthCompare: 'less' },
        });
        this.wireBindGroup = d.createBindGroup({
            layout: this.wireBGL,
            entries: [{ binding: 0, resource: { buffer: this.wireUniformBuffer } }],
        });
    }
    createBindGroups() {
        this.computeBindGroup = this.device.createBindGroup({
            layout: this.computeBGL,
            entries: [
                { binding: 0, resource: { buffer: this.computeUniformBuffer } },
                { binding: 1, resource: { buffer: this.spikeTimesBuffer } },
                { binding: 2, resource: { buffer: this.spikeCountsBuffer } },
                { binding: 3, resource: { buffer: this.activationBuffer } },
                { binding: 4, resource: { buffer: this.modeDataBuffer } },
            ]
        });
        this.renderBindGroup = this.device.createBindGroup({
            layout: this.renderBGL,
            entries: [
                { binding: 0, resource: { buffer: this.renderUniformBuffer } },
                { binding: 1, resource: { buffer: this.positionBuffer } },
                { binding: 2, resource: { buffer: this.activationBuffer } },
            ]
        });
    }
    createGeometry() {
        const sphere = generateIcosahedron();
        this.sphereIndexCount = sphere.indexCount;
        this.sphereVB = this.device.createBuffer({
            size: sphere.positions.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Float32Array(this.sphereVB.getMappedRange()).set(sphere.positions);
        this.sphereVB.unmap();
        this.sphereNB = this.device.createBuffer({
            size: sphere.normals.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Float32Array(this.sphereNB.getMappedRange()).set(sphere.normals);
        this.sphereNB.unmap();
        this.sphereIB = this.device.createBuffer({
            size: sphere.indices.byteLength, usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Uint16Array(this.sphereIB.getMappedRange()).set(sphere.indices);
        this.sphereIB.unmap();
    }
    createWireframe() {
        const wire = generateWireframeBox(2.0); // ¬±2 units
        this.wireVertexCount = wire.vertexCount;
        this.wireVB = this.device.createBuffer({
            size: wire.positions.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Float32Array(this.wireVB.getMappedRange()).set(wire.positions);
        this.wireVB.unmap();
    }
    getEyePos() {
        const d = this.camera.distance;
        const rx = this.camera.rotX, ry = this.camera.rotY;
        return [
            d * Math.cos(rx) * Math.sin(ry) + this.camera.panX,
            d * Math.sin(rx) + this.camera.panY,
            d * Math.cos(rx) * Math.cos(ry) + this.camera.panX * 0,
        ];
    }
    getViewProj() {
        const aspect = this.canvas.width / this.canvas.height;
        const proj = mat4.perspective(mat4.create(), this.camera.fov, aspect, 0.01, 200);
        const eye = this.getEyePos();
        const view = mat4.lookAt(mat4.create(), eye, [this.camera.panX, this.camera.panY, 0], [0,1,0]);
        return mat4.multiply(mat4.create(), proj, view);
    }
    getModelMatrix() {
        const m = mat4.identity(mat4.create());
        return mat4.rotateY(mat4.create(), m, this._mry);
    }
    frame(ts) {
        requestAnimationFrame((t) => this.frame(t));
        const dt = (ts - this._lft);
        this._ld = dt;
        this._lft = ts;
        const cw = this.canvas.clientWidth * devicePixelRatio;
        const ch = this.canvas.clientHeight * devicePixelRatio;
        if (this.canvas.width !== cw || this.canvas.height !== ch) {
            this.canvas.width = cw; this.canvas.height = ch;
            this.createDepthTexture();
            this.ctx.configure({ device: this.device, format: this._pf, alphaMode: 'opaque' });
        }
        if (this._ip && this._dl) {
            const duration = this.maxTime - this.minTime;
            const targetDuration = 10000; // 10 seconds at 1x
            this._ct += dt * this.config.playbackSpeed * (duration / targetDuration);
            if (this._ct > this.maxTime) this._ct = this.minTime;
        }
        if (this.config.autoRotate) {
            this._mry += 0.001 * dt * 0.06;
        }
        this.writeRenderUniforms();
        this.writeWireUniforms();
        const encoder = this.device.createCommandEncoder();
        if (this._dl) {
            this.writeComputeUniforms();
            const computePass = encoder.beginComputePass();
            computePass.setPipeline(this.computePipeline);
            computePass.setBindGroup(0, this.computeBindGroup);
            const workgroups = Math.ceil(this._nc / 256);
            computePass.dispatchWorkgroups(workgroups);
            computePass.end();
        }
        const textureView = this.ctx.getCurrentTexture().createView();
        const renderPass = encoder.beginRenderPass({
            colorAttachments: [{
                view: textureView,
                clearValue: { r: this.config.bgColor[0], g: this.config.bgColor[1], b: this.config.bgColor[2], a: 1 },
                loadOp: 'clear', storeOp: 'store',
            }],
            depthStencilAttachment: {
                view: this._dv,
                depthClearValue: 1.0,
                depthLoadOp: 'clear', depthStoreOp: 'store',
            }
        });
        if (this.config.showContainer) {
            renderPass.setPipeline(this.wirePipeline);
            renderPass.setBindGroup(0, this.wireBindGroup);
            renderPass.setVertexBuffer(0, this.wireVB);
            renderPass.draw(this.wireVertexCount);
        }
        if (this._dl) {
            renderPass.setPipeline(this.pointPipeline);
            renderPass.setBindGroup(0, this.renderBindGroup);
            renderPass.draw(6, this._nc); // 6 verts per quad, N instances
        }
        renderPass.end();
        this.device.queue.submit([encoder.finish()]);
        if (this._sp) {
            this._sp = false;
            this._doScreenshotCapture();
        }
        this._fc++;
        if (ts - this._fpt >= 1000) {
            this.fps = Math.round(this._fc * 1000 / (ts - this._fpt));
            this._fc = 0;
            this._fpt = ts;
            this.updatePerfUI();
            this.updateActiveCount();
        }
        this.updateTimelineUI();
        if (this._dl && this._np && this._fc % 3 === 0) {
            const mm = document.getElementById('minimapPanel');
            if (mm && !mm.classList.contains('hidden')) this.drawMinimap();
        }
        if (this._ir) {
            const elapsed = Math.floor((Date.now() - this._rst) / 1000);
            const m = String(Math.floor(elapsed/60)).padStart(2,'0'), s = String(elapsed%60).padStart(2,'0');
            const rt = document.getElementById('recTimer');
            if (rt) rt.textContent = `REC ${m}:${s}`;
        }
    }
    updateActiveCount() {
        if (!this._dl || !this.data) {
            document.getElementById('hActive').textContent = '‚Äî';
            return;
        }
        if (this.config.mode === 1) {
            document.getElementById('hActive').textContent = '‚Äî';
            return;
        }
        const t = this._ct;
        const w = this.config.activationWindow;
        const maxSPN = this.data.maxSpikesPerNeuron;
        let active = 0;
        const stride = Math.max(1, Math.floor(this._nc / 5000));
        let sampled = 0;
        for (let i = 0; i < this._nc; i += stride) {
            sampled++;
            const sc = this.data.spikeCounts[i];
            if (sc === 0) continue;
            const base = i * maxSPN;
            const count = Math.min(sc, maxSPN);
            for (let s = 0; s < count; s++) {
                const st = this.data.spikeTimes[base + s];
                if (st >= 3.4e+38) break;
                if (Math.abs(st - t) < w) { active++; break; }
            }
        }
        const estimated = Math.round(active * (this._nc / sampled));
        const fmt = (n) => n >= 1e6 ? (n/1e6).toFixed(1)+'M' : n >= 1e3 ? (n/1e3).toFixed(1)+'K' : n.toString();
        document.getElementById('hActive').textContent = fmt(estimated);
    }
    writeComputeUniforms() {
        const buf = new ArrayBuffer(this.computeUniformSize);
        const u32 = new Uint32Array(buf);
        const f32 = new Float32Array(buf);
        u32[0] = this._nc;
        u32[1] = this.data.maxSpikesPerNeuron;
        f32[2] = this._ct;
        f32[3] = this.config.activationWindow;
        f32[4] = this.config.inactiveColor[0]; f32[5] = this.config.inactiveColor[1];
        f32[6] = this.config.inactiveColor[2]; f32[7] = this.config.inactiveColor[3];
        f32[8] = this.config.activeColor[0]; f32[9] = this.config.activeColor[1];
        f32[10] = this.config.activeColor[2]; f32[11] = this.config.activeColor[3];
        u32[12] = this.config.mode;
        u32[13] = this.data.maxSpikeCount;
        f32[14] = this._ld ? this._ld / 1000.0 : 0.016; // seconds
        f32[15] = this.maxTime - this.minTime; // total duration ms
        f32[16] = this.config.gradLow[0]; f32[17] = this.config.gradLow[1];
        f32[18] = this.config.gradLow[2]; f32[19] = this.config.gradLow[3];
        f32[20] = this.config.gradMid[0]; f32[21] = this.config.gradMid[1];
        f32[22] = this.config.gradMid[2]; f32[23] = this.config.gradMid[3];
        f32[24] = this.config.gradHigh[0]; f32[25] = this.config.gradHigh[1];
        f32[26] = this.config.gradHigh[2]; f32[27] = this.config.gradHigh[3];
        f32[28] = this.config.gradMax[0]; f32[29] = this.config.gradMax[1];
        f32[30] = this.config.gradMax[2]; f32[31] = this.config.gradMax[3];
        this.device.queue.writeBuffer(this.computeUniformBuffer, 0, buf);
    }
    writeRenderUniforms() {
        const buf = new ArrayBuffer(this.renderUniformSize);
        const f32 = new Float32Array(buf);
        const vp = this.getViewProj();
        const model = this.getModelMatrix();
        const eye = this.getEyePos();
        f32.set(vp, 0);
        f32.set(model, 16);
        f32[32] = eye[0]; f32[33] = eye[1]; f32[34] = eye[2];
        f32[35] = this.config.pointSize * this.config.neuronScale;
        f32[36] = this.config.inactiveSize;
        f32[37] = this.config.activeSize;
        f32[38] = 0; f32[39] = 0;
        const ld = [0.5, 0.7, 0.5];
        const ll = Math.sqrt(ld[0]*ld[0]+ld[1]*ld[1]+ld[2]*ld[2]);
        f32[40] = ld[0]/ll; f32[41] = ld[1]/ll; f32[42] = ld[2]/ll;
        f32[43] = 0;
        this.device.queue.writeBuffer(this.renderUniformBuffer, 0, buf);
    }
    writeWireUniforms() {
        const buf = new ArrayBuffer(this.wireUniformSize);
        const f32 = new Float32Array(buf);
        f32.set(this.getViewProj(), 0);
        f32.set(this.getModelMatrix(), 16);
        f32[32] = 0; f32[33] = 1; f32[34] = 0.53; f32[35] = 0.5; // green-ish, 50% alpha
        this.device.queue.writeBuffer(this.wireUniformBuffer, 0, buf);
    }
    updateHeaderStats() {
        const fmt = (n) => n >= 1e6 ? (n/1e6).toFixed(2)+'M' : n >= 1e3 ? (n/1e3).toFixed(0)+'K' : n.toString();
        document.getElementById('hNeurons').textContent = this._nc > 0 ? fmt(this._nc) : '‚Äî';
        document.getElementById('hSpikes').textContent = this.data ? fmt(this.data.totalSpikes) : '‚Äî';
    }
    updatePerfUI() {
        const el = document.getElementById('pFps');
        el.textContent = this.fps;
        el.className = 'pval ' + (this.fps >= 50 ? 'fps-hi' : this.fps >= 30 ? 'fps-md' : 'fps-lo');
        document.getElementById('pFrame').textContent = (1000/Math.max(1,this.fps)).toFixed(1) + ' ms';
        document.getElementById('pMem').textContent = (this._gm || 0).toFixed(1) + ' MB';
        document.getElementById('pNeurons').textContent = this._nc.toLocaleString();
    }
    updateTimelineUI() {
        const elapsed = this._ct - this.minTime;
        const duration = this.maxTime - this.minTime;
        const pct = duration > 0 ? (elapsed / duration) * 100 : 0;
        document.getElementById('tlFill').style.width = pct + '%';
        document.getElementById('tlTime').textContent = elapsed.toFixed(1) + ' ms';
    }
    setupControls() {
        const canvas = this.canvas;
        let dragging = false, btn = 0, lastX = 0, lastY = 0;
        canvas.addEventListener('mousedown', (e) => {
            dragging = true; btn = e.button; lastX = e.clientX; lastY = e.clientY;
        });
        window.addEventListener('mouseup', () => { dragging = false; });
        window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const dx = e.clientX - lastX, dy = e.clientY - lastY;
            lastX = e.clientX; lastY = e.clientY;
            if (btn === 0) { // rotate
                this.camera.rotY += dx * 0.005;
                this.camera.rotX = Math.max(-1.5, Math.min(1.5, this.camera.rotX + dy * 0.005));
            } else if (btn === 2) { // pan
                this.camera.panX -= dx * 0.005 * this.camera.distance * 0.1;
                this.camera.panY += dy * 0.005 * this.camera.distance * 0.1;
            }
        });
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            this.camera.distance = Math.max(1, Math.min(50, this.camera.distance * (1 + e.deltaY * 0.001)));
        }, { passive: false });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        let touches = [], lastDist = 0;
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touches = Array.from(e.touches);
            if (touches.length === 2) {
                const dx = touches[0].pageX - touches[1].pageX, dy = touches[0].pageY - touches[1].pageY;
                lastDist = Math.sqrt(dx*dx+dy*dy);
            }
            lastX = touches[0]?.pageX || 0; lastY = touches[0]?.pageY || 0;
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const t = Array.from(e.touches);
            if (t.length === 2 && lastDist > 0) {
                const dx = t[0].pageX - t[1].pageX, dy = t[0].pageY - t[1].pageY;
                const dist = Math.sqrt(dx*dx+dy*dy);
                this.camera.distance = Math.max(1, Math.min(50, this.camera.distance / (dist/lastDist)));
                lastDist = dist;
            } else if (t.length === 1) {
                const dx = t[0].pageX - lastX, dy = t[0].pageY - lastY;
                this.camera.rotY += dx * 0.008;
                this.camera.rotX = Math.max(-1.5, Math.min(1.5, this.camera.rotX + dy * 0.008));
                lastX = t[0].pageX; lastY = t[0].pageY;
            }
        }, { passive: false });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); lastDist = 0; }, { passive: false });
        window.addEventListener('resize', () => {
        });
        window.addEventListener('keydown', (e) => {
            const key = e.key;
            if (key === 'h' || key === 'H') { e.preventDefault(); this.toggleUI(); }
            if (key === 'c' || key === 'C') { e.preventDefault(); this.togglePanel(); }
            if (key === 'f' || key === 'F') {
                e.preventDefault();
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            }
            if (key === ' ') { e.preventDefault(); this.togglePlayPause(); }
            if (key === 'ArrowLeft')  { e.preventDefault(); this.seekTime(-10); }
            if (key === 'ArrowRight') { e.preventDefault(); this.seekTime(10); }
            if (key === 'ArrowUp')   { e.preventDefault(); this.adjustSpeed(0.2); }
            if (key === 'ArrowDown') { e.preventDefault(); this.adjustSpeed(-0.2); }
            if (key === '+' || key === '=') { e.preventDefault(); this.adjustSpeed(0.1); }
            if (key === '-' || key === '_') { e.preventDefault(); this.adjustSpeed(-0.1); }
            if (key === 'w' || key === 'W') { e.preventDefault(); this.adjustWindow(0.5); }
            if (key === 's' || key === 'S') { e.preventDefault(); this.adjustWindow(-0.5); }
            if (key === 'q' || key === 'Q') { e.preventDefault(); this.adjustScale(-0.1); }
            if (key === 'e' || key === 'E') { e.preventDefault(); this.adjustScale(0.1); }
            if (key === '1') { this.setMode(0); this.showToast('‚ö° Real-Time Activity'); }
            if (key === '2') { this.setMode(1); this.showToast('‚óâ Recruitment Map'); }
            if (key === '3') { this.setMode(2); this.showToast('üîÆ Forward Preview'); }
            if (key === '4') { this.setMode(3); this.showToast('üî• Activity Persistence'); }
            if (key === '5') { this.setMode(4); this.showToast('üìä Firing Rate Map'); }
            if (key === '6') { this.setMode(5); this.showToast('üåä Spike History Trail'); }
            if (key === 'r' || key === 'R') { e.preventDefault(); this.resetCamera(); }
            if (key === 't' || key === 'T') {
                e.preventDefault();
                this.config.autoRotate = !this.config.autoRotate;
                this.showToast(this.config.autoRotate ? '‚Üª Auto Rotate ON' : '‚äò Auto Rotate OFF');
            }
            if (key === 'g' || key === 'G') {
                e.preventDefault();
                this.config.showContainer = !this.config.showContainer;
                this.showToast(this.config.showContainer ? '‚ñ¢ Container ON' : '‚ñ¢ Container OFF');
            }
            if (key === 'p' || key === 'P') { e.preventDefault(); this.takeScreenshot(); }
            if (key === 'v' || key === 'V') { e.preventDefault(); this.toggleRecording(); }
            if (key === 'm' || key === 'M') { e.preventDefault(); const mm=document.getElementById('minimapPanel'); if(mm) mm.classList.toggle('hidden'); }
        });
        this.setupSliders();
        this.setupToggles();
        this.setupModeButtons();
        this.setupDatasetButtons();
        this.setupColorPickers();
        this.setupMiscButtons();
    }
    setupSliders() {
        const setupSlider = (id, onChange) => {
            const el = document.getElementById(id);
            const track = el.querySelector('.slider-track');
            const fill = el.querySelector('.slider-fill');
            const thumb = el.querySelector('.slider-thumb');
            const min = parseFloat(el.dataset.min);
            const max = parseFloat(el.dataset.max);
            const step = parseFloat(el.dataset.step) || 0.1;
            let value = parseFloat(el.dataset.value);
            const update = () => {
                const pct = (value - min) / (max - min);
                fill.style.width = (pct * 100) + '%';
                thumb.style.left = (pct * 100) + '%';
            };
            let isDragging = false;
            const handleInput = (clientX) => {
                const rect = track.getBoundingClientRect();
                const pct = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                value = Math.round((min + (max - min) * pct) / step) * step;
                update();
                onChange(value);
            };
            el.addEventListener('mousedown', (e) => { isDragging = true; handleInput(e.clientX); });
            window.addEventListener('mousemove', (e) => { if (isDragging) handleInput(e.clientX); });
            window.addEventListener('mouseup', () => { isDragging = false; });
            el.addEventListener('touchstart', (e) => { isDragging = true; handleInput(e.touches[0].clientX); }, { passive: true });
            el.addEventListener('touchmove', (e) => { if (isDragging) handleInput(e.touches[0].clientX); }, { passive: true });
            update();
            onChange(value);
        };
        setupSlider('sliderScale', (v) => {
            this.config.neuronScale = v;
            document.getElementById('scaleVal').textContent = v.toFixed(1) + 'x';
        });
        setupSlider('sliderSpeed', (v) => {
            this.config.playbackSpeed = v;
            const label = v < 0.01 ? v.toFixed(4) + 'x' : v < 0.1 ? v.toFixed(3) + 'x' : v.toFixed(2) + 'x';
            document.getElementById('speedVal').textContent = label;
        });
        setupSlider('sliderWindow', (v) => {
            this.config.activationWindow = v;
            document.getElementById('windowVal').textContent = v.toFixed(1) + ' ms';
        });
    }
    setupToggles() {
        const setup = (id, onChange) => {
            const el = document.getElementById(id);
            const track = el.querySelector('.toggle-track');
            el.addEventListener('click', () => {
                track.classList.toggle('on');
                onChange(track.classList.contains('on'));
            });
        };
        setup('togContainer', (v) => { this.config.showContainer = v; });
        setup('togRotate', (v) => { this.config.autoRotate = v; });
    }
    setupModeButtons() {
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const modeMap = { spike:0, static:1, hybrid:2, recruit:3, heatmap:4, frequency:5 };
                this.setMode(modeMap[btn.dataset.mode]);
            });
        });
    }
    setMode(m) {
        this.config.mode = m;
        const names = ['Activity','Recruitment','Preview','Persistence','Frequency','Trail'];
        document.getElementById('hMode').textContent = names[m] || 'Activity';
        const modeMap = { spike:0, static:1, hybrid:2, recruit:3, heatmap:4, frequency:5 };
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.classList.toggle('active', modeMap[btn.dataset.mode] === m);
        });
    }
    setupDatasetButtons() {
        document.querySelectorAll('.ds-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                const pct = parseInt(btn.dataset.pct);
                if (pct === this.config.datasetPct) return;
                document.querySelectorAll('.ds-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('dsLabel').textContent = pct + '%';
                this.config.datasetPct = pct;
                await this.reloadWithPercentage(pct);
            });
        });
        document.getElementById('btnLoadData').addEventListener('click', () => {
            document.getElementById('fileInputData').click();
        });
        document.getElementById('fileInputData').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                const file = e.target.files[0];
                const name = file.name.toLowerCase();
                if (name.endsWith('.json')) {
                    this.loadJSONFile(file);
                } else {
                    this.loadBinaryFiles(e.target.files);
                }
            }
        });
        document.getElementById('btnLoadSynthetic').addEventListener('click', async () => {
            const data = generateSyntheticData(288027);
            await this.applyNewDataset(data, 'Synthetic 288K');
        });
    }
    async loadJSONFile(file) {
        const info = document.getElementById('datasetInfo');
        info.textContent = `Loading ${file.name}...`;
        info.style.color = 'var(--blue)';
        try {
            const text = await file.text();
            info.textContent = 'Parsing JSON...';
            const json = JSON.parse(text);
            let positions, spikeEvents;
            if (Array.isArray(json.positions) && json.positions.length > 0) {
                if (Array.isArray(json.positions[0])) {
                    const n = json.positions.length;
                    positions = new Float32Array(n * 3);
                    for (let i = 0; i < n; i++) {
                        positions[i*3]   = json.positions[i][0];
                        positions[i*3+1] = json.positions[i][1];
                        positions[i*3+2] = json.positions[i][2];
                    }
                } else {
                    positions = new Float32Array(json.positions);
                }
            } else {
                throw new Error('No positions array found in JSON');
            }
            const neuronCount = positions.length / 3;
            if (Array.isArray(json.spikes) && json.spikes.length > 0) {
                if (Array.isArray(json.spikes[0])) {
                    spikeEvents = json.spikes;
                } else {
                    spikeEvents = [];
                    for (let i = 0; i < json.spikes.length; i += 2) {
                        spikeEvents.push([json.spikes[i], json.spikes[i+1]]);
                    }
                }
            } else if (json.spikes && json.spikes.neuronIds) {
                spikeEvents = [];
                for (let i = 0; i < json.spikes.neuronIds.length; i++) {
                    spikeEvents.push([json.spikes.neuronIds[i], json.spikes.times[i]]);
                }
            }
            info.textContent = `Building GPU buffers (${neuronCount.toLocaleString()} neurons)...`;
            const data = this.buildSpikeBuffers(positions, spikeEvents, neuronCount);
            await this.applyNewDataset(data, file.name);
        } catch (err) {
            info.textContent = `Error: ${err.message}`;
            info.style.color = 'var(--error)';
        }
    }
    async loadBinaryFiles(files) {
        const info = document.getElementById('datasetInfo');
        info.textContent = 'Loading binary files...';
        info.style.color = 'var(--blue)';
        try {
            const fileMap = {};
            for (const f of files) {
                const name = f.name.toLowerCase();
                fileMap[name] = f;
            }
            if (files.length === 1 && !fileMap['positions.bin']) {
                const buf = await files[0].arrayBuffer();
                await this.loadCombinedBinary(buf, files[0].name);
                return;
            }
            if (!fileMap['positions.bin']) throw new Error('Missing positions.bin');
            if (!fileMap['spiketimes.bin']) throw new Error('Missing spikeTimes.bin');
            if (!fileMap['spikecounts.bin']) throw new Error('Missing spikeCounts.bin');
            const posBuf = await fileMap['positions.bin'].arrayBuffer();
            const stBuf = await fileMap['spiketimes.bin'].arrayBuffer();
            const scBuf = await fileMap['spikecounts.bin'].arrayBuffer();
            const positions = new Float32Array(posBuf);
            const spikeTimes = new Float32Array(stBuf);
            const spikeCounts = new Int32Array(scBuf);
            const neuronCount = spikeCounts.length;
            const maxSpikesPerNeuron = Math.round(spikeTimes.length / neuronCount);
            let minTime = Infinity, maxTime = -Infinity, totalSpikes = 0, maxSC = 0;
            for (let i = 0; i < neuronCount; i++) {
                totalSpikes += spikeCounts[i];
                if (spikeCounts[i] > maxSC) maxSC = spikeCounts[i];
                const base = i * maxSpikesPerNeuron;
                for (let s = 0; s < spikeCounts[i]; s++) {
                    const t = spikeTimes[base + s];
                    if (t < 3.4e38) {
                        if (t < minTime) minTime = t;
                        if (t > maxTime) maxTime = t;
                    }
                }
            }
            if (minTime === Infinity) { minTime = 0; maxTime = 1000; }
            const data = { positions, spikeTimes, spikeCounts, maxSpikesPerNeuron, minTime, maxTime, totalSpikes, maxSpikeCount: maxSC };
            await this.applyNewDataset(data, `${neuronCount} neurons (binary)`);
        } catch (err) {
            info.textContent = `Error: ${err.message}`;
            info.style.color = 'var(--error)';
        }
    }
    async loadCombinedBinary(buf, fileName) {
        const header = new Int32Array(buf, 0, 3);
        const neuronCount = header[0];
        const maxSpikesPerNeuron = header[1];
        const totalSpikesStored = header[2];
        const posOffset = 12;
        const posSize = neuronCount * 3 * 4;
        const stOffset = posOffset + posSize;
        const stSize = neuronCount * maxSpikesPerNeuron * 4;
        const scOffset = stOffset + stSize;
        const positions = new Float32Array(buf.slice(posOffset, posOffset + posSize));
        const spikeTimes = new Float32Array(buf.slice(stOffset, stOffset + stSize));
        const spikeCounts = new Int32Array(buf.slice(scOffset, scOffset + neuronCount * 4));
        let minTime = Infinity, maxTime = -Infinity, totalSpikes = 0, maxSC = 0;
        for (let i = 0; i < neuronCount; i++) {
            const sc = spikeCounts[i];
            totalSpikes += sc;
            if (sc > maxSC) maxSC = sc;
        }
        const sampleStride = Math.max(1, Math.floor(neuronCount / 10000));
        for (let i = 0; i < neuronCount; i += sampleStride) {
            const sc = spikeCounts[i];
            if (sc === 0) continue;
            const base = i * maxSpikesPerNeuron;
            for (let s = 0; s < sc; s++) {
                const t = spikeTimes[base + s];
                if (t >= 3.4e38) break;
                if (t < minTime) minTime = t;
                if (t > maxTime) maxTime = t;
            }
        }
        if (minTime === Infinity) { minTime = 0; maxTime = 1000; }
        const data = { positions, spikeTimes, spikeCounts, maxSpikesPerNeuron, minTime, maxTime, totalSpikes, maxSpikeCount: maxSC };
        await this.applyNewDataset(data, fileName);
    }
    buildSpikeBuffers(positions, spikeEvents, neuronCount) {
        let idCol = 0, timeCol = 1;
        if (spikeEvents && spikeEvents.length > 0) {
            const v0 = spikeEvents[0][0], v1 = spikeEvents[0][1];
            const isInt0 = Math.abs(v0 - Math.round(v0)) < 0.01;
            const isInt1 = Math.abs(v1 - Math.round(v1)) < 0.01;
            if (!isInt0 && isInt1) { idCol = 1; timeCol = 0; }
        }
        const counts = new Int32Array(neuronCount);
        if (spikeEvents) {
            for (const ev of spikeEvents) {
                const nid = Math.round(ev[idCol]);
                if (nid >= 0 && nid < neuronCount) counts[nid]++;
            }
        }
        let maxSPN = 0;
        for (let i = 0; i < neuronCount; i++) {
            if (counts[i] > maxSPN) maxSPN = counts[i];
        }
        maxSPN = Math.min(maxSPN, 1000); // Cap like Unity
        const flat = new Float32Array(neuronCount * maxSPN);
        flat.fill(3.4028235e+38);
        const idx = new Int32Array(neuronCount);
        const sorted = spikeEvents ? spikeEvents
            .map(ev => ({ id: Math.round(ev[idCol]), time: ev[timeCol] }))
            .filter(ev => ev.id >= 0 && ev.id < neuronCount)
            .sort((a, b) => a.id - b.id || a.time - b.time) : [];
        let minTime = Infinity, maxTime = -Infinity, totalSpikes = 0;
        for (const sp of sorted) {
            if (idx[sp.id] < maxSPN) {
                flat[sp.id * maxSPN + idx[sp.id]] = sp.time;
                idx[sp.id]++;
                totalSpikes++;
                if (sp.time < minTime) minTime = sp.time;
                if (sp.time > maxTime) maxTime = sp.time;
            }
        }
        if (minTime === Infinity) { minTime = 0; maxTime = 1000; }
        const cappedCounts = new Int32Array(neuronCount);
        for (let i = 0; i < neuronCount; i++) cappedCounts[i] = Math.min(counts[i], maxSPN);
        let maxSC = 0;
        for (let i = 0; i < neuronCount; i++) { if (cappedCounts[i] > maxSC) maxSC = cappedCounts[i]; }
        return { positions, spikeTimes: flat, spikeCounts: cappedCounts, maxSpikesPerNeuron: maxSPN, minTime, maxTime, totalSpikes, maxSpikeCount: maxSC };
    }
    async applyNewDataset(data, label, isFullDataset = true) {
        const wasPlaying = this._ip;
        this._ip = false;
        if (isFullDataset) {
            this._fd = {
                positions: new Float32Array(data.positions),
                spikeTimes: new Float32Array(data.spikeTimes),
                spikeCounts: new Int32Array(data.spikeCounts),
                maxSpikesPerNeuron: data.maxSpikesPerNeuron,
            };
        }
        this.data = data;
        this._nc = data.positions.length / 3;
        this.minTime = data.minTime;
        this.maxTime = data.maxTime;
        this._ct = this.minTime;
        if (isFullDataset) {
            this.config.datasetPct = 100;
            document.querySelectorAll('.ds-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('.ds-btn[data-pct="100"]').classList.add('active');
            document.getElementById('dsLabel').textContent = '100%';
        }
        if (this.positionBuffer) this.positionBuffer.destroy();
        if (this.spikeTimesBuffer) this.spikeTimesBuffer.destroy();
        if (this.spikeCountsBuffer) this.spikeCountsBuffer.destroy();
        if (this.activationBuffer) this.activationBuffer.destroy();
        if (this.modeDataBuffer) this.modeDataBuffer.destroy();
        this.createBuffers();
        this.createBindGroups();
        this.updateHeaderStats();
        document.getElementById('tlTotal').textContent = (this.maxTime - this.minTime).toFixed(1) + ' ms';
        const info = document.getElementById('datasetInfo');
        info.textContent = `${label}: ${this._nc.toLocaleString()} neurons, ${data.totalSpikes.toLocaleString()} spikes`;
        info.style.color = 'var(--primary)';
        this._dl = true;
        this._ip = wasPlaying;
    }
    async reloadWithPercentage(pct) {
        if (this._fd) {
            const fullN = this._fd.positions.length / 3;
            const newN = Math.floor(fullN * pct / 100);
            const positions = this._fd.positions.slice(0, newN * 3);
            const maxSPN = this._fd.maxSpikesPerNeuron;
            const spikeTimes = new Float32Array(newN * maxSPN);
            spikeTimes.fill(3.4028235e+38);
            const spikeCounts = new Int32Array(newN);
            let totalSpikes = 0, maxSC = 0, minT = Infinity, maxT = -Infinity;
            for (let i = 0; i < newN; i++) {
                spikeCounts[i] = this._fd.spikeCounts[i];
                if (spikeCounts[i] > maxSC) maxSC = spikeCounts[i];
                totalSpikes += spikeCounts[i];
                const srcBase = i * maxSPN, dstBase = i * maxSPN;
                for (let s = 0; s < spikeCounts[i] && s < maxSPN; s++) {
                    const t = this._fd.spikeTimes[srcBase + s];
                    spikeTimes[dstBase + s] = t;
                    if (t < 3.4e38) { if (t < minT) minT = t; if (t > maxT) maxT = t; }
                }
            }
            if (minT === Infinity) { minT = 0; maxT = 1000; }
            const data = { positions, spikeTimes, spikeCounts, maxSpikesPerNeuron: maxSPN, minTime: minT, maxTime: maxT, totalSpikes, maxSpikeCount: maxSC };
            await this.applyNewDataset(data, `${pct}% of ${fullN.toLocaleString()} neurons`, false);
        } else {
            const fullCount = 288027;
            const newCount = Math.floor(fullCount * pct / 100);
            const data = generateSyntheticData(newCount);
            await this.applyNewDataset(data, `Synthetic ${pct}%`, false);
        }
    }
    setupColorPickers() {
        const hexToRgb = (hex) => {
            const r = parseInt(hex.slice(1,3),16)/255;
            const g = parseInt(hex.slice(3,5),16)/255;
            const b = parseInt(hex.slice(5,7),16)/255;
            return [r,g,b,1];
        };
        const setup = (swatchId, pickId, hexId, configKey) => {
            const swatch = document.getElementById(swatchId);
            const pick = document.getElementById(pickId);
            const hex = document.getElementById(hexId);
            swatch.addEventListener('click', () => pick.click());
            pick.addEventListener('input', (e) => {
                swatch.style.backgroundColor = e.target.value;
                hex.textContent = e.target.value;
                this.config[configKey] = hexToRgb(e.target.value);
            });
        };
        setup('swatchInactive', 'pickInactive', 'hexInactive', 'inactiveColor');
        setup('swatchActive', 'pickActive', 'hexActive', 'activeColor');
        const bgSwatch = document.getElementById('swatchBg');
        const bgPick = document.getElementById('pickBg');
        const bgHex = document.getElementById('hexBg');
        if (bgSwatch && bgPick) {
            bgSwatch.addEventListener('click', () => bgPick.click());
            bgPick.addEventListener('input', (e) => {
                bgSwatch.style.backgroundColor = e.target.value;
                bgHex.textContent = e.target.value;
                const c = hexToRgb(e.target.value);
                this.config.bgColor = [c[0], c[1], c[2]];
            });
        }
    }
    setupMiscButtons() {
        document.getElementById('btnPlayPause').addEventListener('click', () => this.togglePlayPause());
        document.getElementById('fabToggle').addEventListener('click', () => this.toggleUI());
        const ssBtn = document.getElementById('btnScreenshot');
        if (ssBtn) ssBtn.addEventListener('click', () => this.takeScreenshot());
        const recBtn = document.getElementById('btnRecord');
        if (recBtn) recBtn.addEventListener('click', () => this.toggleRecording());
        document.getElementById('cpanelToggle').addEventListener('click', () => {
            const body = document.getElementById('cpanelBody');
            body.style.display = body.style.display === 'none' ? 'block' : 'none';
            document.getElementById('cpanelToggle').textContent = body.style.display === 'none' ? '‚ñº' : '‚ñ≤';
        });
        document.getElementById('timeline').addEventListener('click', (e) => {
            const rect = e.currentTarget.getBoundingClientRect();
            const pct = (e.clientX - rect.left) / rect.width;
            this._ct = this.minTime + pct * (this.maxTime - this.minTime);
        });
    }
    takeScreenshot() {
        this._sp = true;
        this.showToast('üì∑ Capturing...');
    }
    _doScreenshotCapture() {
        const canvas = this.canvas;
        const tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = canvas.width;
        tmpCanvas.height = canvas.height;
        const ctx2 = tmpCanvas.getContext('2d');
        ctx2.drawImage(canvas, 0, 0);
        tmpCanvas.toBlob(blob => {
            if (!blob) { this.showToast('‚ö† Capture failed'); return; }
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const ts = new Date().toISOString().replace(/[:.]/g,'-').slice(0,19);
            a.download = `NeuroConstellation_${ts}.png`;
            a.href = url; a.click(); URL.revokeObjectURL(url);
            this.showToast('üì∑ Screenshot saved');
        }, 'image/png');
    }
    toggleRecording() {
        if (this._ir) this.stopRecording();
        else this.startRecording();
    }
    startRecording() {
        const stream = this.canvas.captureStream(60);
        this._rc = [];
        try {
            this._mr = new MediaRecorder(stream, { mimeType:'video/webm;codecs=vp9', videoBitsPerSecond:8000000 });
        } catch(e) {
            this._mr = new MediaRecorder(stream, { mimeType:'video/webm', videoBitsPerSecond:8000000 });
        }
        this._mr.ondataavailable = e => { if(e.data.size>0) this._rc.push(e.data); };
        this._mr.onstop = () => {
            const blob = new Blob(this._rc, {type:'video/webm'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const ts = new Date().toISOString().replace(/[:.]/g,'-').slice(0,19);
            a.download = `NeuroConstellation_${ts}.webm`;
            a.href = url; a.click(); URL.revokeObjectURL(url);
            this.showToast('üé¨ Video saved');
        };
        this._mr.start(100);
        this._ir = true; this._rst = Date.now();
        const badge = document.getElementById('recBadge');
        if (badge) badge.classList.add('show');
        this.showToast('‚è∫ Recording started');
    }
    stopRecording() {
        if (this._mr && this._mr.state !== 'inactive') this._mr.stop();
        this._ir = false;
        const badge = document.getElementById('recBadge');
        if (badge) badge.classList.remove('show');
    }
    drawMinimap() {
        const mc = document.getElementById('minimapCanvas');
        if (!mc || !this._np) return;
        const ctx2 = mc.getContext('2d'), w = mc.width, h = mc.height;
        ctx2.fillStyle = 'rgba(5,5,8,0.95)'; ctx2.fillRect(0,0,w,h);
        const n = this._nc, stride = Math.max(1, Math.floor(n/4000));
        ctx2.fillStyle = 'rgba(0,150,255,0.4)';
        for (let i=0;i<n;i+=stride) {
            const x=this._np[i*3], z=this._np[i*3+2];
            ctx2.fillRect((x/4+0.5)*w, (z/4+0.5)*h, 1.5, 1.5);
        }
        const eye=this.getEyePos(), cx=(eye[0]/4+0.5)*w, cz=(eye[2]/4+0.5)*h;
        ctx2.fillStyle='#00ff88'; ctx2.beginPath(); ctx2.arc(cx,cz,4,0,Math.PI*2); ctx2.fill();
        const dir=Math.atan2(-eye[0],-eye[2]);
        ctx2.strokeStyle='#00ff88'; ctx2.lineWidth=1.5; ctx2.beginPath();
        ctx2.moveTo(cx,cz); ctx2.lineTo(cx+Math.sin(dir)*18,cz+Math.cos(dir)*18); ctx2.stroke();
    }
    setCameraPreset(name) {
        const presets = { front:{rotX:0,rotY:0}, top:{rotX:1.56,rotY:0}, side:{rotX:0,rotY:1.57}, angle:{rotX:0.5,rotY:0.7}, back:{rotX:0,rotY:3.14}, reset:{rotX:0.5,rotY:0} };
        const p = presets[name]; if(!p) return;
        const start={rotX:this.camera.rotX,rotY:this.camera.rotY,panX:this.camera.panX,panY:this.camera.panY};
        const dur=500, t0=performance.now();
        const ease=t=>t<0.5?2*t*t:1-Math.pow(-2*t+2,2)/2;
        const animate=()=>{
            const t=Math.min(1,(performance.now()-t0)/dur), e=ease(t);
            this.camera.rotX=start.rotX+(p.rotX-start.rotX)*e;
            this.camera.rotY=start.rotY+(p.rotY-start.rotY)*e;
            if(name==='reset'){this.camera.panX=start.panX*(1-e);this.camera.panY=start.panY*(1-e);this._mry*=(1-e);}
            if(t<1)requestAnimationFrame(animate);
        };
        animate();
        this.showToast(`üìê ${name.charAt(0).toUpperCase()+name.slice(1)}`);
    }
    togglePlayPause() {
        this._ip = !this._ip;
        document.getElementById('btnPlayPause').textContent = this._ip ? '‚è∏ Pause' : '‚ñ∂ Play';
        this.showToast(this._ip ? '‚ñ∂ Playing' : '‚è∏ Paused');
    }
    adjustSpeed(delta) {
        if (delta > 0) {
            this.config.playbackSpeed = Math.min(5.0, this.config.playbackSpeed < 0.1 ? this.config.playbackSpeed * 2 : this.config.playbackSpeed + delta);
        } else {
            this.config.playbackSpeed = Math.max(0.001, this.config.playbackSpeed < 0.1 ? this.config.playbackSpeed / 2 : this.config.playbackSpeed + delta);
        }
        const s = this.config.playbackSpeed;
        const label = s < 0.01 ? s.toFixed(4) + 'x' : s < 0.1 ? s.toFixed(3) + 'x' : s.toFixed(2) + 'x';
        document.getElementById('speedVal').textContent = label;
        this.updateSlider('sliderSpeed', s);
        this.showToast(`‚ö° Speed ${label}`);
    }
    adjustWindow(delta) {
        this.config.activationWindow = Math.max(0.1, Math.min(10.0, this.config.activationWindow + delta));
        this.config.activationWindow = Math.round(this.config.activationWindow * 10) / 10;
        document.getElementById('windowVal').textContent = this.config.activationWindow.toFixed(1) + ' ms';
        this.updateSlider('sliderWindow', this.config.activationWindow);
        this.showToast(`‚óâ Window ${this.config.activationWindow.toFixed(1)} ms`);
    }
    adjustScale(delta) {
        this.config.neuronScale = Math.max(0.1, Math.min(5.0, this.config.neuronScale + delta));
        this.config.neuronScale = Math.round(this.config.neuronScale * 10) / 10;
        document.getElementById('scaleVal').textContent = this.config.neuronScale.toFixed(1) + 'x';
        this.updateSlider('sliderScale', this.config.neuronScale);
        this.showToast(`‚¨§ Scale ${this.config.neuronScale.toFixed(1)}x`);
    }
    seekTime(deltaMs) {
        if (!this._dl) return;
        this._ct += deltaMs;
        if (this._ct > this.data.maxTime) this._ct = this.data.minTime;
        if (this._ct < this.data.minTime) this._ct = this.data.maxTime;
        this.showToast(`${deltaMs > 0 ? '‚è©' : '‚è™'} ${this._ct.toFixed(1)} ms`);
    }
    togglePanel() {
        const panel = document.getElementById('controlPanel');
        panel.classList.toggle('hidden');
    }
    updateSlider(id, value) {
        const el = document.getElementById(id);
        if (!el) return;
        const min = parseFloat(el.dataset.min);
        const max = parseFloat(el.dataset.max);
        const pct = Math.max(0, Math.min(100, (value - min) / (max - min) * 100));
        const fill = el.querySelector('.slider-fill');
        const thumb = el.querySelector('.slider-thumb');
        if (fill) fill.style.width = pct + '%';
        if (thumb) thumb.style.left = pct + '%';
        el.dataset.value = value;
    }
    showToast(msg) {
        let toast = document.getElementById('kbToast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'kbToast';
            document.body.appendChild(toast);
        }
        toast.textContent = msg;
        toast.className = 'kb-toast show';
        clearTimeout(this._tt);
        this._tt = setTimeout(() => { toast.className = 'kb-toast'; }, 1200);
    }
    resetCamera() {
        this.camera = { distance: 8, rotX: 0.5, rotY: 0, panX: 0, panY: 0, fov: 75 * Math.PI / 180 };
        this._mry = 0;
        this.showToast('‚ü≤ Camera Reset');
    }
    toggleUI() {
        this._uv = !this._uv;
        ['mainHeader','controlPanel','perfMon','infoBar','minimapPanel'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.classList.toggle('hidden', !this._uv);
        });
    }
}
window.addEventListener('DOMContentLoaded', () => {
    window._app = new NeuroConstellationWeb();
});
</script>
</body>
</html>
