<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuroConstellation Web ‚Äî GPU-Accelerated Neural Visualisation</title>
    <meta name="description" content="NeuroConstellation Web: Real-time WebGPU visualisation of large-scale hippocampal neural networks. Supports 288K‚Äì5.28M neurons with 6 scientifically validated visualisation modes. Port of the Unity NeuroConstellation platform.">
    <meta name="author" content="Safeer Ali Mirani, Pirah Memon, Paolo Enrico, Sergio M.G. Solinas">
    <meta name="keywords" content="neural visualisation, WebGPU, hippocampus, GPU computing, computational neuroscience, spike detection, real-time rendering">
    <meta name="application-name" content="NeuroConstellation Web">
    <meta name="version" content="1.0.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='%23050508'/><circle cx='50' cy='20' r='5' fill='%2300ff88'/><circle cx='20' cy='50' r='5' fill='%230099ff'/><circle cx='80' cy='50' r='5' fill='%239966ff'/><circle cx='50' cy='80' r='5' fill='%2300ff88'/><circle cx='50' cy='50' r='8' fill='%2300ff88'/></svg>">
    <meta property="og:title" content="NeuroConstellation Web ‚Äî GPU-Accelerated Neural Visualisation">
    <meta property="og:description" content="Real-time WebGPU visualisation of large-scale hippocampal neural networks with 6 validated visualisation modes.">
    <meta property="og:type" content="website">
    <!-- 
        NeuroConstellation Web v1.0.0
        ==============================
        GPU-Accelerated Browser-Based Neural Network Visualisation Platform
        
        Author:     Safeer Ali Mirani
        Affiliation: University of Sassari (UNISS), Department of Life Sciences and Biotechnologies
        Collaborator: Pirah Memon (Researcher, UNISS)
        Supervisors: Prof. Dr. Paolo Enrico, Prof. Dr. Sergio M.G. Solinas
        Funding:    EBRAINS-Italy, MUR-PNRR M4.C2.I1.4 (CUP B51E22000150006)
        
        Technical Architecture:
        - WebGPU compute shaders (WGSL) ‚Äî direct port of Unity HLSL NeuronCompute.compute
        - Billboard instanced rendering ‚Äî port of NeuronUnifiedShader.shader
        - Binary data pipeline ‚Äî port of VarjoNeuronDataManager.cs
        - 6 scientifically validated visualisation modes (thesis Table 8)
        
        Part of PhD Thesis: "Real-Time Visualisation of Large-Scale Neural Networks:
        GPU-Accelerated Methods for Desktop and Mixed Reality Platforms"
        
        Related Publications:
        - Paper 1 (Chapter 4): NeuroConstellation Desktop (Cell Reports Methods)
        - Paper 2 (Chapter 5): HoloNeV Mixed Reality (Journal of Neural Engineering)
        - Paper 3 (Chapter 6): HoloLens 2 Hand Gesture Interaction
        - Paper 4 (Chapter 7): Varjo XR-4 VR Visualisation
        
        ¬© 2025 Safeer Ali Mirani, University of Sassari. Licensed under MIT.
    -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --primary: #00ff88;
            --primary-dark: #00cc6a;
            --bg: #0a0a0a;
            --panel: rgba(15,15,15,0.95);
            --border: rgba(255,255,255,0.1);
            --text: #ffffff;
            --text2: #a0a0a0;
            --blue: #0099ff;
            --purple: #9966ff;
            --error: #ff4444;
            --inactive: #3366ff;
            --gradient-low: #3333cc;
            --gradient-mid: #00ffcc;
            --gradient-high: #ffcc00;
            --gradient-max: #ff3300;
        }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg); color: var(--text);
            overflow: hidden; line-height: 1.5;
        }
        canvas#gpuCanvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            cursor: grab; background: #000;
        }
        canvas#gpuCanvas:active { cursor: grabbing; }

        /* ============ INTRO SCREEN ============ */
        .intro-overlay {
            position: fixed; inset: 0; z-index: 2000;
            background: radial-gradient(ellipse at 50% 30%, rgba(0,40,80,0.3), #050508 70%);
            display: flex; align-items: center; justify-content: center;
            opacity: 1; transition: opacity 0.8s ease-out;
        }
        .intro-overlay.hidden { opacity: 0; pointer-events: none; }
        .intro-box {
            text-align: center; max-width: 760px; padding: 40px;
            animation: fadeUp 1s ease-out;
            max-height: 92vh; overflow-y: auto; position: relative;
        }
        .intro-glow {
            position: absolute; top: -120px; left: 50%; transform: translateX(-50%);
            width: 400px; height: 400px; border-radius: 50%;
            background: radial-gradient(circle, rgba(0,255,136,0.08), transparent 70%);
            pointer-events: none; animation: pulse 4s ease-in-out infinite;
        }
        @keyframes pulse { 0%,100%{opacity:0.5;transform:translateX(-50%) scale(1);} 50%{opacity:1;transform:translateX(-50%) scale(1.1);} }
        @keyframes fadeUp { from { opacity:0; transform:translateY(30px); } to { opacity:1; transform:translateY(0); } }
        .intro-badge {
            display: inline-block; padding: 5px 16px; border-radius: 20px; font-size: 11px;
            font-weight: 600; letter-spacing: 1.5px; text-transform: uppercase;
            background: rgba(0,255,136,0.1); border: 1px solid rgba(0,255,136,0.2);
            color: var(--primary); margin-bottom: 16px;
        }
        .intro-box h1 {
            font-size: 42px; font-weight: 800; margin-bottom: 12px; letter-spacing: -0.5px;
            background: linear-gradient(135deg, #00ff88 0%, #00ccff 50%, #9966ff 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: fadeUp 1s ease-out 0.1s both;
        }
        .web-suffix { font-weight: 300; opacity: 0.8; font-size: 36px; }
        .intro-box .subtitle { font-size: 14px; color: var(--text2); margin-bottom: 28px; line-height: 1.8; animation: fadeUp 1s ease-out 0.2s both; }
        .intro-card {
            margin-bottom: 20px; padding: 22px;
            background: rgba(255,255,255,0.03); border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.06);
            animation: fadeUp 1s ease-out 0.3s both;
        }
        .intro-card .name { font-size: 26px; font-weight: 700; color: var(--primary); margin-bottom: 6px; }
        .intro-card .role { font-size: 15px; color: var(--text); }
        .intro-card .affil { font-size: 13px; color: var(--text2); }
        .intro-card .fund { font-size: 13px; color: var(--blue); font-style: italic; margin-top: 4px; }
        .intro-card a { font-size: 13px; color: var(--primary); text-decoration: none; }
        .collab-card {
            margin-bottom: 20px; padding: 18px;
            background: rgba(0,153,255,0.05); border-radius: 12px;
            border: 1px solid rgba(0,153,255,0.1);
            animation: fadeUp 1s ease-out 0.4s both;
        }
        .collab-card .label { font-size: 11px; color: var(--text2); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
        .collab-card .cname { font-size: 18px; font-weight: 600; color: var(--blue); }
        .collab-card .crole { font-size: 13px; color: var(--text2); }
        .super-card {
            margin-bottom: 20px; padding: 18px;
            background: rgba(0,255,136,0.04); border-radius: 12px;
            border: 1px solid rgba(0,255,136,0.1);
            animation: fadeUp 1s ease-out 0.5s both;
        }
        .super-card .label { font-size: 11px; color: var(--text2); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
        .super-card .names { display: flex; justify-content: center; gap: 28px; }
        .super-card .names span { font-size: 17px; font-weight: 600; color: var(--primary); }
        .ack-card {
            margin-bottom: 28px; padding: 18px;
            background: rgba(255,255,255,0.02); border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.05);
            font-size: 13px; color: var(--text2); line-height: 1.7; font-style: italic;
            animation: fadeUp 1s ease-out 0.6s both;
        }
        .ack-card .label { font-size: 11px; color: var(--text2); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; font-style: normal; font-weight: 600; }
        .enter-btn {
            padding: 16px 44px; display: inline-flex; align-items: center; gap: 8px;
            background: linear-gradient(135deg, var(--primary), #00ccff);
            color: #050508; border: none; border-radius: 30px;
            font-size: 16px; font-weight: 700; cursor: pointer;
            box-shadow: 0 4px 24px rgba(0,255,136,0.35), 0 0 60px rgba(0,255,136,0.1);
            transition: all 0.3s; animation: fadeUp 1s ease-out 0.7s both;
        }
        .enter-btn:hover { transform: translateY(-3px) scale(1.02); box-shadow: 0 8px 36px rgba(0,255,136,0.5), 0 0 80px rgba(0,255,136,0.15); }
        .enter-icon { font-size: 18px; }
        .tech-section { margin-top: 22px; animation: fadeUp 1s ease-out 0.8s both; }
        .tech-row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .tech-badge {
            padding: 3px 11px; background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08); border-radius: 16px;
            font-size: 11px; color: var(--text2);
        }
        .shortcut-preview {
            display: flex; gap: 16px; justify-content: center; flex-wrap: wrap;
            margin-top: 14px; font-size: 11px; color: rgba(255,255,255,0.25);
        }
        .shortcut-preview span { letter-spacing: 0.3px; }

        /* ============ LOADING SCREEN ============ */
        .loading-overlay {
            position: fixed; inset: 0; z-index: 1500;
            background: var(--bg); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s;
        }
        .loading-overlay.visible { display: flex; }
        .loading-overlay.fade { opacity: 0; }
        .loading-box { text-align: center; max-width: 400px; }
        .loading-box h2 {
            font-size: 22px; font-weight: 600; margin-bottom: 8px;
            background: linear-gradient(135deg, var(--primary), var(--blue));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .loading-box .sub { color: var(--text2); margin-bottom: 24px; font-size: 14px; }
        .progress-track { width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; margin-bottom: 16px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--primary), var(--blue)); width: 0%; transition: width 0.3s; }
        .loading-status { font-size: 13px; color: var(--text2); }

        /* ============ ERROR SCREEN ============ */
        .error-overlay {
            position: fixed; inset: 0; z-index: 3000;
            background: var(--bg); display: none;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .error-overlay.visible { display: flex; }
        .error-box { text-align: center; max-width: 500px; padding: 40px; }
        .error-box h2 { font-size: 24px; color: var(--error); margin-bottom: 16px; }
        .error-box p { color: var(--text2); margin-bottom: 12px; font-size: 14px; line-height: 1.6; }
        .error-box a { color: var(--primary); }

        /* ============ HEADER ============ */
        .header {
            position: absolute; top: 0; left: 0; right: 0; height: 56px;
            background: linear-gradient(180deg, rgba(5,5,8,0.95) 0%, rgba(5,5,8,0.7) 70%, transparent 100%);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 28px; z-index: 100;
            transition: opacity 0.3s, transform 0.3s;
        }
        .header.hidden { opacity: 0; pointer-events: none; }
        .logo { display: flex; align-items: center; gap: 10px; }
        .logo svg { width: 28px; height: 28px; }
        .logo span {
            font-size: 17px; font-weight: 600;
            background: linear-gradient(135deg, var(--primary), var(--blue));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .hstats { display: flex; gap: 28px; }
        .hstat { text-align: center; }
        .hstat .val { font-size: 18px; font-weight: 600; color: var(--primary); }
        .hstat .lbl { font-size: 11px; color: var(--text2); text-transform: uppercase; letter-spacing: 0.5px; }

        /* ============ CONTROL PANEL ============ */
        .cpanel {
            position: absolute; top: 72px; left: 28px; width: 340px;
            background: var(--panel); backdrop-filter: blur(20px);
            border: 1px solid var(--border); border-radius: 14px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5); z-index: 100;
            transition: opacity 0.3s, transform 0.3s;
            max-height: calc(100vh - 100px); overflow-y: auto;
        }
        .cpanel.hidden { opacity: 0; transform: translateX(-20px); pointer-events: none; }
        .cpanel-head {
            padding: 16px 18px; border-bottom: 1px solid var(--border);
            display: flex; align-items: center; justify-content: space-between;
        }
        .cpanel-head h3 { font-size: 15px; font-weight: 600; }
        .cpanel-head button {
            background: none; border: none; color: var(--text2); cursor: pointer;
            width: 24px; height: 24px; border-radius: 6px; display: flex; align-items: center; justify-content: center;
        }
        .cpanel-head button:hover { background: rgba(255,255,255,0.1); color: var(--text); }
        .cpanel-body { padding: 16px 18px; }
        .csection { margin-bottom: 20px; }
        .csection:last-child { margin-bottom: 0; }
        .csection-title { font-size: 11px; font-weight: 600; color: var(--text2); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px; }
        .citem { margin-bottom: 14px; }
        .citem-label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; font-size: 13px; }
        .citem-val { font-weight: 600; color: var(--primary); font-family: 'SF Mono','Monaco','Consolas', monospace; font-size: 12px; }

        /* Slider */
        .slider-wrap { position: relative; height: 28px; cursor: pointer; }
        .slider-track { position: absolute; top: 12px; left: 0; right: 0; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; }
        .slider-fill { position: absolute; top: 0; left: 0; height: 100%; background: linear-gradient(90deg, var(--primary), var(--primary-dark)); border-radius: 2px; }
        .slider-thumb {
            position: absolute; top: 8px; width: 12px; height: 12px;
            background: var(--primary); border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,255,136,0.5);
            transform: translateX(-50%); transition: transform 0.1s;
        }
        .slider-wrap:hover .slider-thumb { transform: translateX(-50%) scale(1.2); }

        /* Toggle */
        .toggle-row { display: flex; align-items: center; justify-content: space-between; cursor: pointer; font-size: 13px; }
        .toggle-track {
            position: relative; width: 40px; height: 22px;
            background: rgba(255,255,255,0.1); border-radius: 11px;
            transition: background 0.3s; flex-shrink: 0;
        }
        .toggle-track.on { background: var(--primary); }
        .toggle-knob {
            position: absolute; top: 2px; left: 2px; width: 18px; height: 18px;
            background: #fff; border-radius: 50%; transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-track.on .toggle-knob { transform: translateX(18px); }

        /* Mode buttons */
        .mode-btns { display: flex; gap: 6px; flex-wrap: wrap; }
        .mode-btn {
            flex: 1; min-width: 80px; padding: 8px 12px;
            background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15);
            color: var(--text2); border-radius: 8px; font-size: 12px; font-weight: 500;
            cursor: pointer; transition: all 0.2s; text-align: center;
        }
        .mode-btn.active { background: var(--primary); color: var(--bg); border-color: var(--primary); font-weight: 600; }
        .mode-btn:hover:not(.active) { background: rgba(255,255,255,0.12); color: var(--text); }

        /* Buttons */
        .btn {
            width: 100%; padding: 10px 18px; border: none; border-radius: 8px;
            font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.3s;
        }
        .btn-primary { background: var(--primary); color: var(--bg); }
        .btn-primary:hover { background: var(--primary-dark); transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,255,136,0.4); }
        .btn-secondary { background: rgba(255,255,255,0.1); color: var(--text); }
        .btn-secondary:hover { background: rgba(255,255,255,0.15); }

        /* Color picker */
        .cpick-row { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
        .cpick-swatch {
            width: 28px; height: 28px; border-radius: 6px;
            border: 2px solid rgba(255,255,255,0.2); cursor: pointer; transition: all 0.2s;
        }
        .cpick-swatch:hover { transform: scale(1.1); border-color: var(--primary); }
        .cpick-input { position: absolute; opacity: 0; pointer-events: none; }
        .cpick-hex { font-size: 12px; color: var(--text2); font-family: 'SF Mono','Monaco','Consolas', monospace; }

        /* Timeline */
        .timeline {
            height: 42px; background: rgba(255,255,255,0.05); border-radius: 8px;
            position: relative; cursor: pointer; overflow: hidden; margin-bottom: 12px;
        }
        .timeline-fill {
            position: absolute; top: 0; left: 0; height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--blue));
            opacity: 0.2; transition: width 0.1s;
        }
        .timeline-info {
            position: absolute; top: 50%; left: 14px; transform: translateY(-50%);
            display: flex; align-items: center; gap: 10px; pointer-events: none;
        }
        .timeline-time { font-size: 13px; font-weight: 600; color: var(--text); min-width: 55px; }
        .timeline-total { font-size: 11px; color: var(--text2); }

        /* ============ PERF MONITOR ============ */
        .perfmon {
            position: absolute; top: 60px; right: 28px;
            background: var(--panel); backdrop-filter: blur(20px);
            border: 1px solid var(--border); border-radius: 12px;
            padding: 10px 14px; min-width: 170px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5); z-index: 100;
            transition: opacity 0.3s, transform 0.3s;
        }
        .perfmon.hidden { opacity: 0; transform: translateX(20px); pointer-events: none; }
        .perfmon h4 { font-size: 11px; font-weight: 600; color: var(--text2); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 10px; }
        .pstat { display: flex; justify-content: space-between; margin-bottom: 3px; font-size: 11px; }
        .pstat .plbl { color: var(--text2); }
        .pstat .pval { font-weight: 600; font-family: 'SF Mono','Monaco','Consolas', monospace; }
        .fps-hi { color: var(--primary); }
        .fps-md { color: var(--blue); }
        .fps-lo { color: var(--error); }

        /* ============ INFO BAR ============ */
        .infobar {
            position: absolute; bottom: 0; left: 0; right: 0; height: 28px;
            background: rgba(5,5,8,0.9);
            border-top: 1px solid var(--border);
            display: flex; gap: 8px; align-items: center; justify-content: center;
            z-index: 90; overflow: hidden;
            transition: opacity 0.3s;
            font-size: 10px;
        }
        .infobar.hidden { opacity: 0; pointer-events: none; }
        .infobar .iitem { display: flex; align-items: center; gap: 4px; color: var(--text2); }

        /* ============ FAB BUTTONS ============ */
        .fab {
            position: fixed; bottom: 20px; right: 20px; width: 46px; height: 46px;
            border-radius: 50%; background: rgba(10,10,10,0.9);
            border: 2px solid rgba(0,255,136,0.5); color: var(--primary);
            cursor: pointer; z-index: 999; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5); backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        .fab:hover { transform: scale(1.1); background: rgba(0,255,136,0.3); box-shadow: 0 0 20px rgba(0,255,136,0.5); }

        /* Dataset loading selector */
        .dataset-btns { display: flex; gap: 4px; }
        .ds-btn {
            flex: 1; padding: 6px 8px;
            background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12);
            color: var(--text2); border-radius: 6px; font-size: 11px; font-weight: 500;
            cursor: pointer; transition: all 0.2s; text-align: center;
        }
        .ds-btn.active { background: var(--blue); color: #fff; border-color: var(--blue); }
        .ds-btn:hover:not(.active) { background: rgba(255,255,255,0.1); }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 3px; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }

        @media (max-width: 768px) {
            .cpanel { left: 16px; right: 16px; width: auto; max-width: 360px; }
            .perfmon { display: none; }
            .hstats { display: none; }
            .infobar { display: none; }
        }

        /* Keyboard toast notification */
        .kb-toast {
            position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%) translateY(20px);
            padding: 10px 24px; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px);
            border: 1px solid rgba(0,255,136,0.3); border-radius: 24px;
            color: var(--primary); font-size: 14px; font-weight: 600; z-index: 200;
            opacity: 0; transition: opacity 0.3s, transform 0.3s; pointer-events: none;
            font-family: 'SF Mono','Monaco','Consolas', monospace;
        }
        .kb-toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

        /* Recording badge */
        @keyframes recBlink { 0%,100%{opacity:1;} 50%{opacity:0.3;} }
        #recBadge { display:none; }
        #recBadge.show { display:flex; }

        /* Citation block */
        .cite-block { font-size:11px; color:var(--text2); line-height:1.6; margin-top:8px; }
    </style>
</head>
<body>
    <canvas id="gpuCanvas"></canvas>

    <!-- ============ INTRO SCREEN ============ -->
    <div class="intro-overlay" id="introOverlay">
        <div class="intro-box">
            <div class="intro-glow"></div>
            <div class="intro-badge">WebGPU Neural Visualisation Platform</div>
            <h1>NeuroConstellation<span class="web-suffix">Web</span></h1>
            <p class="subtitle">Real-time GPU-accelerated visualisation of large-scale hippocampal neural networks<br>288K‚Äì5.28M neurons ¬∑ WGSL compute shader spike detection ¬∑ 6 validated visualisation modes</p>

            <div class="intro-card">
                <div class="name">Safeer Ali Mirani</div>
                <div class="role">PhD Candidate, Department of Life Sciences and Biotechnologies</div>
                <div class="affil">University of Sassari (UNISS), Italy</div>
                <div class="fund">Funded by EBRAINS-Italy ¬∑ MUR-PNRR M4.C2.I1.4 ¬∑ CUP B51E22000150006</div>
                <a href="mailto:safeer.ali.mirani@gmail.com">safeer.ali.mirani@gmail.com</a>
            </div>

            <div class="collab-card">
                <div class="label">In Collaboration With</div>
                <div class="cname">Pirah Memon</div>
                <div class="crole">Researcher, Department of Life Sciences and Biotechnologies, University of Sassari (UNISS), Italy</div>
            </div>

            <div class="super-card">
                <div class="label">Under the Kind Supervision of</div>
                <div class="names">
                    <span>Prof. Dr. Paolo Enrico</span>
                    <span>Prof. Dr. Sergio M.G. Solinas</span>
                </div>
                <div style="text-align:center;margin-top:6px;"><a href="mailto:smgsolinas@uniss.it" style="font-size:13px;color:var(--primary);text-decoration:none;">smgsolinas@uniss.it</a></div>
            </div>

            <div class="ack-card">
                <div class="label">Acknowledgments</div>
                <div>We express our sincere gratitude to Prof. Dr. Paolo Enrico and Prof. Dr. Sergio M.G. Solinas for their kind and continuous supervision and support throughout this research.</div>
                <div style="margin-top:6px;">This research was funded by Project IR00011 EBRAINS-Italy, Mission 4 'Istruzione e Ricerca', Component 2 'Dalla ricerca all'impresa', Line of investment 3.1 of PNRR (European Union NextGeneration EU, CUP B51E22000150006).</div>
                <div class="cite-block" style="margin-top:10px;border-top:1px solid rgba(255,255,255,0.06);padding-top:8px;font-style:normal;">
                    <strong style="color:var(--text);font-size:10px;">Cite as:</strong><br>
                    Mirani, S.A., Memon, P., Enrico, P., & Solinas, S.M.G. (2025). NeuroConstellation Web: Browser-Based GPU-Accelerated Neural Network Visualisation. University of Sassari.<br>
                    <span style="color:rgba(255,255,255,0.3);">Part of PhD Thesis: "Real-Time Visualisation of Large-Scale Neural Networks: GPU-Accelerated Methods for Desktop and Mixed Reality Platforms"</span>
                </div>
            </div>

            <button class="enter-btn" id="enterBtn">
                <span class="enter-icon">‚ö°</span> Enter Visualisation
            </button>

            <div class="tech-section">
                <div class="tech-row">
                    <span class="tech-badge">WebGPU</span>
                    <span class="tech-badge">WGSL Compute</span>
                    <span class="tech-badge">Billboard Instancing</span>
                    <span class="tech-badge">Binary Streaming</span>
                    <span class="tech-badge">6 Visualisation Modes</span>
                </div>
                <div class="shortcut-preview">
                    <span>Space: Play</span>
                    <span>‚Üë‚Üì: Speed</span>
                    <span>‚Üê‚Üí: Seek</span>
                    <span>W/S: Window</span>
                    <span>Q/E: Scale</span>
                    <span>1-6: Modes</span>
                    <span>F: Fullscreen</span>
                    <span>H: Hide UI</span>
                </div>
            </div>
        </div>
    </div>

    <!-- ============ LOADING SCREEN ============ -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-box">
            <h2>NeuroConstellation Web</h2>
            <p class="sub" id="loadingSub">Initialising WebGPU...</p>
            <div class="progress-track"><div class="progress-fill" id="progressFill"></div></div>
            <p class="loading-status" id="loadingStatus">Requesting GPU adapter...</p>
        </div>
    </div>

    <!-- ============ ERROR SCREEN ============ -->
    <div class="error-overlay" id="errorOverlay">
        <div class="error-box">
            <h2>Initialisation Error</h2>
            <p class="err-msg" style="color:#ff6b6b;font-family:monospace;font-size:13px;background:rgba(255,0,0,0.08);padding:12px;border-radius:8px;margin-bottom:16px;">Unknown error</p>
            <p>This visualisation requires <strong>WebGPU</strong> support:</p>
            <p style="margin-top:8px;font-size:13px;color:var(--text2);">Chrome 113+ ¬∑ Edge 113+ ¬∑ Firefox 141+ ¬∑ Safari 18+</p>
            <p style="margin-top:12px;font-size:12px;color:var(--text2);">If your browser supports WebGPU, try: close all tabs and reopen, or check <code style="color:var(--primary);">chrome://gpu</code> for WebGPU status.</p>
        </div>
    </div>

    <!-- ============ HEADER ============ -->
    <header class="header" id="mainHeader">
        <div class="logo">
            <svg viewBox="0 0 100 100" fill="none"><circle cx="50" cy="20" r="6" fill="#00ff88"/><circle cx="20" cy="50" r="6" fill="#0099ff"/><circle cx="80" cy="50" r="6" fill="#9966ff"/><circle cx="50" cy="80" r="6" fill="#00ff88"/><path d="M50 26L20 50M50 26L80 50M20 50L50 74M80 50L50 74" stroke="#00ff88" stroke-width="2" opacity="0.6"/><circle cx="50" cy="50" r="10" fill="#00ff88"/></svg>
            <span>NeuroConstellation<span style="font-weight:300;opacity:0.7;">Web</span></span>
            <span style="font-size:11px;padding:3px 10px;background:#00ff88;border-radius:10px;color:#000;margin-left:8px;font-weight:700;-webkit-text-fill-color:#000;-webkit-background-clip:border-box;">v1.0</span>
        </div>
        <div class="hstats">
            <div class="hstat"><div class="val" id="hNeurons">0</div><div class="lbl">Neurons</div></div>
            <div class="hstat"><div class="val" id="hSpikes">0</div><div class="lbl">Spikes</div></div>
            <div class="hstat"><div class="val" id="hActive">0</div><div class="lbl">Active</div></div>
            <div class="hstat"><div class="val" id="hMode">Spike</div><div class="lbl">Mode</div></div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
            <button class="btn btn-secondary" id="btnScreenshot" style="width:auto;padding:8px 14px;font-size:14px;border-radius:8px;" title="Screenshot (P)">üì∑</button>
            <button class="btn btn-secondary" id="btnRecord" style="width:auto;padding:8px 14px;font-size:14px;border-radius:8px;" title="Record (V)">‚è∫ Rec</button>
        </div>
    </header>

    <!-- ============ CONTROL PANEL ============ -->
    <div class="cpanel" id="controlPanel">
        <div class="cpanel-head">
            <h3>Visualisation Controls</h3>
            <button id="cpanelToggle">‚ñ≤</button>
        </div>
        <div class="cpanel-body" id="cpanelBody">

            <!-- Dataset Loading -->
            <div class="csection">
                <div class="csection-title">Dataset</div>

                <!-- File upload -->
                <div class="citem">
                    <div class="citem-label"><span>Load Data</span></div>
                    <button class="btn btn-primary" id="btnLoadData" style="margin-bottom:8px;">Load Dataset (.bin / .json)</button>
                    <button class="btn btn-secondary" id="btnLoadSynthetic" style="margin-bottom:8px;">Load Synthetic (288K)</button>
                    <input type="file" id="fileInputData" accept=".bin,.dat,.json" style="display:none;">
                    <div id="datasetInfo" style="font-size:11px; color:var(--text2); line-height:1.6; margin-bottom:8px;">
                        No dataset loaded ‚Äî click above to load
                    </div>
                </div>

                <!-- Progressive loading -->
                <div class="citem">
                    <div class="citem-label"><span>Scale</span><span class="citem-val" id="dsLabel">100%</span></div>
                    <div class="dataset-btns">
                        <button class="ds-btn" data-pct="25">25%</button>
                        <button class="ds-btn" data-pct="50">50%</button>
                        <button class="ds-btn" data-pct="75">75%</button>
                        <button class="ds-btn active" data-pct="100">100%</button>
                    </div>
                </div>
            </div>

            <!-- Visualisation Mode -->
            <div class="csection">
                <div class="csection-title">Visualisation Mode (1-6)</div>
                <div class="mode-btns" style="margin-bottom:4px;">
                    <button class="mode-btn active" data-mode="spike" title="Mode 1: Ai(t) = max(0, 1‚àíŒît/w)">‚ö° Activity</button>
                    <button class="mode-btn" data-mode="static" title="Mode 2: 3-state recruitment logic">‚óâ Recruit</button>
                    <button class="mode-btn" data-mode="hybrid" title="Mode 3: Vi(t) = max(Ai(t), Ai(t+wp)√ó0.7)">üîÆ Preview</button>
                </div>
                <div class="mode-btns">
                    <button class="mode-btn" data-mode="recruit" title="Mode 4: Exponential decay œÑ=200ms">üî• Persist</button>
                    <button class="mode-btn" data-mode="heatmap" title="Mode 5: Log-normalised log‚ÇÇ(f+1)/log‚ÇÇ(201)">üìä Freq</button>
                    <button class="mode-btn" data-mode="frequency" title="Mode 6: 5 checkpoints at 0,5,10,20,40ms">üåä Trail</button>
                </div>
            </div>

            <!-- Display -->
            <div class="csection">
                <div class="csection-title">Display</div>
                <div class="citem">
                    <div class="citem-label"><span>Neuron Scale</span><span class="citem-val" id="scaleVal">1.0x</span></div>
                    <div class="slider-wrap" id="sliderScale" data-min="0.1" data-max="5" data-value="1" data-step="0.1">
                        <div class="slider-track"><div class="slider-fill"></div></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="citem">
                    <div class="toggle-row" id="togContainer">
                        <span>Wireframe Container</span>
                        <div class="toggle-track"><div class="toggle-knob"></div></div>
                    </div>
                </div>
                <div class="citem">
                    <div class="toggle-row" id="togRotate">
                        <span>Auto Rotate</span>
                        <div class="toggle-track"><div class="toggle-knob"></div></div>
                    </div>
                </div>
            </div>

            <!-- Colours -->
            <div class="csection">
                <div class="csection-title">Neuron Colours</div>
                <div class="citem">
                    <div class="citem-label"><span>Inactive</span></div>
                    <div class="cpick-row">
                        <div class="cpick-swatch" id="swatchInactive" style="background:#3366ff;"></div>
                        <input type="color" class="cpick-input" id="pickInactive" value="#3366ff">
                        <span class="cpick-hex" id="hexInactive">#3366ff</span>
                    </div>
                </div>
                <div class="citem">
                    <div class="citem-label"><span>Active</span></div>
                    <div class="cpick-row">
                        <div class="cpick-swatch" id="swatchActive" style="background:#ff4d1a;"></div>
                        <input type="color" class="cpick-input" id="pickActive" value="#ff4d1a">
                        <span class="cpick-hex" id="hexActive">#ff4d1a</span>
                    </div>
                </div>
                <div class="citem">
                    <div class="citem-label"><span>Background</span></div>
                    <div class="cpick-row">
                        <div class="cpick-swatch" id="swatchBg" style="background:#030408;"></div>
                        <input type="color" class="cpick-input" id="pickBg" value="#030408">
                        <span class="cpick-hex" id="hexBg">#030408</span>
                    </div>
                </div>
            </div>

            <!-- Playback -->
            <div class="csection">
                <div class="csection-title">Activity Playback</div>
                <div class="citem">
                    <div class="citem-label"><span>Speed</span><span class="citem-val" id="speedVal">1.0x</span></div>
                    <div class="slider-wrap" id="sliderSpeed" data-min="0.001" data-max="5" data-value="0.01" data-step="0.001">
                        <div class="slider-track"><div class="slider-fill"></div></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="citem">
                    <div class="citem-label"><span>Activation Window</span><span class="citem-val" id="windowVal">1.0 ms</span></div>
                    <div class="slider-wrap" id="sliderWindow" data-min="0.1" data-max="10" data-value="1" data-step="0.1">
                        <div class="slider-track"><div class="slider-fill"></div></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="timeline" id="timeline">
                    <div class="timeline-fill" id="tlFill"></div>
                    <div class="timeline-info">
                        <div class="timeline-time" id="tlTime">0.00 ms</div>
                        <div class="timeline-total">/ <span id="tlTotal">0 ms</span></div>
                    </div>
                </div>
                <button class="btn btn-secondary" id="btnPlayPause">‚è∏ Pause</button>
            </div>

            <!-- Camera -->
            <div class="csection">
                <div class="csection-title">Camera</div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:4px;margin-bottom:8px;">
                    <button class="btn btn-secondary" onclick="window._app.setCameraPreset('front')" style="font-size:10px;padding:5px;">Front</button>
                    <button class="btn btn-secondary" onclick="window._app.setCameraPreset('top')" style="font-size:10px;padding:5px;">Top</button>
                    <button class="btn btn-secondary" onclick="window._app.setCameraPreset('side')" style="font-size:10px;padding:5px;">Side</button>
                    <button class="btn btn-secondary" onclick="window._app.setCameraPreset('angle')" style="font-size:10px;padding:5px;">45¬∞</button>
                    <button class="btn btn-secondary" onclick="window._app.setCameraPreset('back')" style="font-size:10px;padding:5px;">Back</button>
                    <button class="btn btn-primary" onclick="window._app.setCameraPreset('reset')" style="font-size:10px;padding:5px;">Reset</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ============ PERF MONITOR ============ -->
    <div class="perfmon" id="perfMon">
        <h4>Performance</h4>
        <div class="pstat"><span class="plbl">FPS</span><span class="pval fps-hi" id="pFps">0</span></div>
        <div class="pstat"><span class="plbl">Frame</span><span class="pval" id="pFrame">0.0 ms</span></div>
        <div class="pstat"><span class="plbl">VRAM</span><span class="pval" id="pMem">0 MB</span></div>
        <div class="pstat"><span class="plbl">Neurons</span><span class="pval" id="pNeurons">0</span></div>
        <div class="pstat"><span class="plbl">Pipeline</span><span class="pval" id="pCompute">Billboard</span></div>
        <div class="pstat"><span class="plbl">GPU</span><span class="pval" id="pGPU" style="font-size:9px;">‚Äî</span></div>
    </div>

    <!-- ============ INFO BAR ============ -->
    <div class="infobar" id="infoBar">
        <div class="iitem" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">Drag: rotate ¬∑ Right: pan ¬∑ Scroll: zoom ¬∑ Space: play ¬∑ ‚Üë‚Üì: speed ¬∑ ‚Üê‚Üí: seek ¬∑ W/S: window ¬∑ Q/E: scale ¬∑ 1-6: mode ¬∑ P: capture ¬∑ V: record ¬∑ M: map ¬∑ T: rotate ¬∑ G: box ¬∑ F: full ¬∑ H: hide ¬∑ C: panel ¬∑ R: reset</div>
    </div>

    <!-- FAB: toggle UI -->
    <button class="fab" id="fabToggle" title="Toggle UI (H)">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
    </button>

    <!-- Recording badge -->
    <div id="recBadge" style="position:fixed;top:60px;left:50%;transform:translateX(-50%);padding:6px 18px;background:rgba(255,0,0,0.15);border:1px solid rgba(255,0,0,0.3);border-radius:20px;color:#ff4444;font-size:12px;font-weight:700;z-index:200;align-items:center;gap:8px;">
        <div style="width:8px;height:8px;border-radius:50%;background:#ff4444;animation:recBlink 1s infinite;"></div>
        <span id="recTimer">REC 00:00</span>
    </div>

    <!-- Minimap ‚Äî right side, below perf monitor -->
    <div id="minimapPanel" style="position:absolute;top:255px;right:28px;z-index:99;width:170px;height:160px;border-radius:10px;border:1px solid rgba(255,255,255,0.08);overflow:hidden;background:rgba(5,5,8,0.9);">
        <canvas id="minimapCanvas" width="340" height="320" style="width:100%;height:100%;display:block;"></canvas>
        <div style="position:absolute;bottom:3px;left:0;right:0;text-align:center;font-size:9px;color:rgba(255,255,255,0.2);font-weight:600;letter-spacing:0.5px;">TOP VIEW</div>
    </div>

<!-- ================================================================
     NEUROCONSTELLATION WEB v1.0.0
     Browser-Based GPU-Accelerated Neural Network Visualisation Engine
     
     Architecture: Direct port of Unity NeuroConstellation pipeline
       NeuronCompute.compute (HLSL) ‚Üí WGSL compute shader (6 kernels)
       NeuronUnifiedShader.shader  ‚Üí WGSL billboard instanced renderer
       VarjoNeuronDataManager.cs   ‚Üí Binary/JSON data loader
       VarjoNeuronVisualizer.cs    ‚Üí WebGPU render pipeline
     
     Validated against thesis Table 8: Six Visualisation Modes
       Mode 1: Real-Time Activity     (CalculateActivations)
       Mode 2: Recruitment Map         (CalculateAllTimeActivations)
       Mode 3: Forward Preview         (CalculateForwardPreview)
       Mode 4: Activity Persistence    (CalculateActivationHeatmap)
       Mode 5: Firing Rate Map         (CalculateSpikeFrequency)
       Mode 6: Spike History Trail     (CalculateSpikeHistoryTrail)
     
     GPU Buffer Layout (128-byte uniform):
       Binding 0: Params uniform   ‚Äî mode, time, colours, gradients
       Binding 1: spikeTimes       ‚Äî Float32[N √ó maxSpikesPerNeuron]
       Binding 2: spikeCounts      ‚Äî Int32[N]
       Binding 3: activations      ‚Äî vec4f[N] (activity, r, g, b)
       Binding 4: modeData         ‚Äî Float32[N] (persistent heatmap)
     ================================================================ -->
<script>
// ============================================================
// WGSL SHADERS ‚Äî Direct port of Unity CGPROGRAM pipeline
// ============================================================

// Port of NeuronCompute.compute CalculateActivations kernel
// Thread group size 256, matching Unity [numthreads(256,1,1)]
const COMPUTE_SHADER_WGSL = /* wgsl */`

struct Params {
    neuronCount: u32,          // offset 0
    maxSpikesPerNeuron: u32,   // offset 4
    currentTime: f32,          // offset 8
    activationWindow: f32,     // offset 12
    inactiveColor: vec4f,      // offset 16 (vec4 aligned to 16)
    activeColor: vec4f,        // offset 32
    mode: u32,                 // offset 48
    maxSpikeCount: u32,        // offset 52
    deltaTime: f32,            // offset 56 ‚Äî frame dt in seconds
    totalDuration: f32,        // offset 60 ‚Äî total simulation time ms
    gradLow: vec4f,            // offset 64
    gradMid: vec4f,            // offset 80
    gradHigh: vec4f,           // offset 96
    gradMax: vec4f,            // offset 112
    // Total: 128 bytes
};

@group(0) @binding(0) var<uniform> params: Params;
@group(0) @binding(1) var<storage, read> spikeTimes: array<f32>;
@group(0) @binding(2) var<storage, read> spikeCounts: array<i32>;
@group(0) @binding(3) var<storage, read_write> activations: array<vec4f>;
@group(0) @binding(4) var<storage, read_write> modeData: array<f32>; // persistent per-neuron data

// Port of CalculateGradient from NeuronUnifiedShader
fn calcGradient(rawT: f32) -> vec3f {
    let t = pow(rawT, 0.35);
    if (t < 0.25) { return mix(params.gradLow.rgb, params.gradMid.rgb, t * 4.0); }
    else if (t < 0.6) { return mix(params.gradMid.rgb, params.gradHigh.rgb, (t - 0.25) / 0.35); }
    else { return mix(params.gradHigh.rgb, params.gradMax.rgb, (t - 0.6) / 0.4); }
}

// Frequency colour gradient: Blue(0Hz)->Cyan(25Hz)->Green(50Hz)->Yellow(75Hz)->Red(100+Hz)
// Matches thesis Fig.19c
fn calcFreqGradient(t: f32) -> vec3f {
    if (t < 0.25) { return mix(vec3f(0.05, 0.1, 0.6), vec3f(0.0, 0.7, 0.9), t * 4.0); }
    else if (t < 0.5) { return mix(vec3f(0.0, 0.7, 0.9), vec3f(0.0, 0.85, 0.2), (t - 0.25) * 4.0); }
    else if (t < 0.75) { return mix(vec3f(0.0, 0.85, 0.2), vec3f(1.0, 0.9, 0.0), (t - 0.5) * 4.0); }
    else { return mix(vec3f(1.0, 0.9, 0.0), vec3f(1.0, 0.15, 0.0), (t - 0.75) * 4.0); }
}

// Thesis: Ai(t) = max(0, 1 - dt/w)
fn checkActivation(neuronId: u32) -> f32 {
    let sc = spikeCounts[neuronId];
    if (sc == 0) { return 0.0; }
    let baseIndex = neuronId * params.maxSpikesPerNeuron;
    var minDiff: f32 = 1e30;
    let count = min(u32(sc), params.maxSpikesPerNeuron);
    for (var i: u32 = 0u; i < count; i++) {
        let st = spikeTimes[baseIndex + i];
        if (st >= 1e30) { break; }
        let d = abs(st - params.currentTime);
        if (d < minDiff) { minDiff = d; }
        if (minDiff < params.activationWindow) { break; }
    }
    if (minDiff < params.activationWindow) { return 1.0 - (minDiff / params.activationWindow); }
    return 0.0;
}

// Forward preview: check activation at future time
// Thesis: Vi(t) = max(Ai(t), Ai(t + wp) * 0.7)
fn checkFutureActivation(neuronId: u32, offset: f32) -> f32 {
    let sc = spikeCounts[neuronId];
    if (sc == 0) { return 0.0; }
    let baseIndex = neuronId * params.maxSpikesPerNeuron;
    let futureTime = params.currentTime + offset;
    var minDiff: f32 = 1e30;
    let count = min(u32(sc), params.maxSpikesPerNeuron);
    for (var i: u32 = 0u; i < count; i++) {
        let st = spikeTimes[baseIndex + i];
        if (st >= 1e30) { break; }
        let d = abs(st - futureTime);
        if (d < minDiff) { minDiff = d; }
        if (minDiff < params.activationWindow) { break; }
    }
    if (minDiff < params.activationWindow) { return 1.0 - (minDiff / params.activationWindow); }
    return 0.0;
}

// Spike history trail: 5 checkpoints at 0, 5, 10, 20, 40 ms past
// Thesis: fading coefficients for temporal propagation patterns
fn checkAtOffset(baseIndex: u32, count: u32, offset: f32) -> f32 {
    let checkTime = params.currentTime - offset;
    if (checkTime < 0.0) { return 0.0; }
    for (var i: u32 = 0u; i < count; i++) {
        let st = spikeTimes[baseIndex + i];
        if (st >= 1e30) { return 0.0; }
        if (abs(st - checkTime) < params.activationWindow) { return 1.0; }
    }
    return 0.0;
}

fn calcSpikeTrail(neuronId: u32) -> f32 {
    let sc = spikeCounts[neuronId];
    if (sc == 0) { return 0.0; }
    let baseIndex = neuronId * params.maxSpikesPerNeuron;
    let count = min(u32(sc), params.maxSpikesPerNeuron);
    var trail: f32 = 0.0;
    trail += checkAtOffset(baseIndex, count, 0.0) * 1.0;
    trail += checkAtOffset(baseIndex, count, 5.0) * 0.7;
    trail += checkAtOffset(baseIndex, count, 10.0) * 0.45;
    trail += checkAtOffset(baseIndex, count, 20.0) * 0.25;
    trail += checkAtOffset(baseIndex, count, 40.0) * 0.1;
    return clamp(trail, 0.0, 1.0);
}

// 6 modes matching Unity NeuroConstellation (thesis Table 8)
@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3u) {
    let nid = gid.x;
    if (nid >= params.neuronCount) { return; }
    var activity: f32;
    var color: vec3f;

    if (params.mode == 0u) {
        // MODE 1: Real-Time Activity (CalculateActivations)
        // Ai(t) = max(0, 1 - dt/w)
        let act = checkActivation(nid);
        activity = act;
        color = mix(params.inactiveColor.rgb, params.activeColor.rgb, act);

    } else if (params.mode == 1u) {
        // MODE 2: Recruitment Map (CalculateAllTimeActivations)
        // 3-state: currently active=full, ever spiked=50% opacity, never=dim
        let sc = spikeCounts[nid];
        let currentAct = checkActivation(nid);
        if (currentAct > 0.1) {
            activity = 1.0;
            color = params.activeColor.rgb;
        } else if (sc > 0) {
            activity = 0.5;
            color = mix(params.inactiveColor.rgb, params.activeColor.rgb, 0.5);
        } else {
            activity = 0.0;
            color = params.inactiveColor.rgb * 0.3;
        }

    } else if (params.mode == 2u) {
        // MODE 3: Forward Preview (CalculateForwardPreview)
        // Vi(t) = max(Ai(t), Ai(t + wp) * 0.7), preview 5ms ahead
        let currentAct = checkActivation(nid);
        let futureAct = checkFutureActivation(nid, 5.0);
        let previewStrength = max(currentAct, futureAct * 0.7);
        activity = previewStrength;
        let previewColor = vec3f(0.2, 0.5, 1.0);
        if (currentAct > futureAct * 0.7) {
            color = mix(params.inactiveColor.rgb, params.activeColor.rgb, currentAct);
        } else {
            color = mix(params.inactiveColor.rgb, previewColor, futureAct * 0.7);
        }

    } else if (params.mode == 3u) {
        // MODE 4: Activity Persistence (CalculateActivationHeatmap)
        // Exponential decay tau=200ms, stores in ModeData buffer
        let act = checkActivation(nid);
        var heat = modeData[nid];
        let tau = 0.2; // 200ms (thesis Fig.19d)
        let decay = exp(-params.deltaTime / tau);
        heat = heat * decay + act;
        heat = min(heat, 3.0);
        modeData[nid] = heat;
        let normHeat = clamp(heat / 2.0, 0.0, 1.0);
        activity = normHeat;
        color = calcFreqGradient(normHeat);

    } else if (params.mode == 4u) {
        // MODE 5: Firing Rate Map (CalculateSpikeFrequency)
        // Log-normalised frequencies, blue(0Hz)->red(100+Hz)
        let sc = spikeCounts[nid];
        let dur = max(params.totalDuration, 1.0);
        let freq = f32(sc) / (dur * 0.001);
        let logFreq = log2(freq + 1.0) / log2(201.0);
        let t = clamp(logFreq, 0.0, 1.0);
        activity = 0.0;
        color = calcFreqGradient(t);

    } else if (params.mode == 5u) {
        // MODE 6: Spike History Trail (CalculateSpikeHistoryTrail)
        // 5 checkpoints: 0, 5, 10, 20, 40ms with fading coefficients
        let trail = calcSpikeTrail(nid);
        activity = trail;
        color = mix(vec3f(0.08, 0.03, 0.01), vec3f(1.0, 0.6, 0.1), trail);

    } else {
        activity = 0.0;
        color = params.inactiveColor.rgb;
    }

    activations[nid] = vec4f(activity, color.r, color.g, color.b);
}
`;

// Vertex + fragment shaders for instanced neuron rendering
// Port of NeuronUnifiedShader vertex/fragment passes
const RENDER_SHADER_WGSL = /* wgsl */`

struct Camera {
    viewProj: mat4x4f,       // offset 0, size 64
    model: mat4x4f,          // offset 64, size 64
    cameraPosAndSize: vec4f,  // offset 128: xyz=cameraPos, w=pointSize
    sizesAndPad: vec4f,       // offset 144: x=inactiveSize, y=activeSize, zw=pad
    lightDirAndPad: vec4f,    // offset 160: xyz=lightDir, w=pad
    // Total: 176 bytes
};

@group(0) @binding(0) var<uniform> cam: Camera;
@group(0) @binding(1) var<storage, read> positions: array<f32>; // packed XYZ (12 bytes per neuron)
// Activations: vec4f per neuron (activity, r, g, b)
@group(0) @binding(2) var<storage, read> activations: array<vec4f>;

struct VSOut {
    @builtin(position) pos: vec4f,
    @location(0) color: vec3f,
    @location(1) normal: vec3f,
    @location(2) worldPos: vec3f,
};

@vertex
fn vsMain(
    @location(0) localPos: vec3f,
    @location(1) localNorm: vec3f,
    @builtin(instance_index) iid: u32,
) -> VSOut {
    var o: VSOut;
    let act = activations[iid]; // (activity, r, g, b)
    let activity = act.x;
    let color = act.yzw;
    let inactiveSize = cam.sizesAndPad.x;
    let activeSize = cam.sizesAndPad.y;
    let pointSize = cam.cameraPosAndSize.w;
    let sizeMul = mix(inactiveSize, activeSize, activity);
    let finalSize = pointSize * sizeMul;
    let scaled = localPos * finalSize;
    let neuronPos = vec3f(positions[iid*3u], positions[iid*3u+1u], positions[iid*3u+2u]);
    let transformed = (cam.model * vec4f(neuronPos, 1.0)).xyz;
    let worldPos = transformed + scaled;
    o.pos = cam.viewProj * vec4f(worldPos, 1.0);
    o.color = color;
    o.normal = localNorm;
    o.worldPos = worldPos;
    return o;
}

@fragment
fn fsMain(inp: VSOut) -> @location(0) vec4f {
    let n = normalize(inp.normal);
    let l = normalize(cam.lightDirAndPad.xyz);
    let ndotl = max(dot(n, l), 0.0);
    let diffuse = ndotl * 0.7 + 0.3;
    var c = inp.color * diffuse;
    // Specular
    let v = normalize(cam.cameraPosAndSize.xyz - inp.worldPos);
    let h = normalize(l + v);
    let spec = pow(max(dot(n, h), 0.0), 32.0) * 0.3;
    c += vec3f(spec);
    return vec4f(c, 1.0);
}
`;

// Billboard quad shader ‚Äî 6 vertices per neuron, camera-facing circles
// Provides depth cues via distance-based brightness attenuation
const POINT_SHADER_WGSL = /* wgsl */`

struct Camera {
    viewProj: mat4x4f,
    model: mat4x4f,
    cameraPosAndSize: vec4f,
    sizesAndPad: vec4f,
    lightDirAndPad: vec4f,
};

@group(0) @binding(0) var<uniform> cam: Camera;
@group(0) @binding(1) var<storage, read> positions: array<f32>; // packed XYZ (12 bytes per neuron)
@group(0) @binding(2) var<storage, read> activations: array<vec4f>;

struct VSOut {
    @builtin(position) pos: vec4f,
    @location(0) color: vec3f,
    @location(1) uv: vec2f,
    @location(2) depth: f32,
};

// 6 vertices for a quad (2 triangles)
const QUAD_UV = array<vec2f, 6>(
    vec2f(-1.0, -1.0), vec2f(1.0, -1.0), vec2f(1.0, 1.0),
    vec2f(-1.0, -1.0), vec2f(1.0, 1.0), vec2f(-1.0, 1.0),
);

@vertex
fn vsPoint(
    @builtin(vertex_index) vid: u32,
    @builtin(instance_index) iid: u32,
) -> VSOut {
    var o: VSOut;
    let act = activations[iid];
    let activity = act.x;
    let neuronPos = vec3f(positions[iid*3u], positions[iid*3u+1u], positions[iid*3u+2u]);
    let worldPos = (cam.model * vec4f(neuronPos, 1.0)).xyz;

    // Billboard offset (camera-facing quad)
    let corner = QUAD_UV[vid];
    let camPos = cam.cameraPosAndSize.xyz;
    let toCamera = normalize(camPos - worldPos);
    // Approximate camera right/up from viewProj (extract from first row and second row)
    let right = normalize(cross(toCamera, vec3f(0.0, 1.0, 0.0)));
    let up = cross(right, toCamera);

    // Size: base from uniform, modulated by activity
    let inactiveSize = cam.sizesAndPad.x;
    let activeSize = cam.sizesAndPad.y;
    let baseSize = cam.cameraPosAndSize.w;
    let sizeMul = mix(inactiveSize, activeSize, activity);
    // Distance-based size attenuation ‚Äî closer neurons appear larger
    let dist = length(camPos - worldPos);
    let distScale = clamp(4.0 / max(dist, 0.1), 0.3, 2.0);
    let quadSize = baseSize * sizeMul * distScale;

    let offset = right * corner.x * quadSize + up * corner.y * quadSize;
    let finalPos = worldPos + offset;

    o.pos = cam.viewProj * vec4f(finalPos, 1.0);
    o.color = act.yzw;
    o.uv = corner;
    // Depth for attenuation (distance from camera)
    o.depth = length(camPos - worldPos);
    return o;
}

@fragment
fn fsPoint(inp: VSOut) -> @location(0) vec4f {
    let d = length(inp.uv);
    if (d > 1.0) { discard; }

    // Glowing core ‚Äî bright center fading to edge
    let glow = exp(-d * d * 3.0);
    let rim = smoothstep(1.0, 0.6, d) * 0.3;

    // Depth-based atmospheric fog ‚Äî distant neurons fade into deep blue
    let depthNorm = clamp((inp.depth - 1.5) * 0.1, 0.0, 1.0);
    let fogColor = vec3f(0.02, 0.04, 0.12);
    let depthFade = 1.0 - depthNorm * 0.85;

    // Base color with glow intensification
    let baseColor = inp.color;
    let brightness = max(baseColor.r, max(baseColor.g, baseColor.b));

    // Active neurons get extra bloom and saturation
    let isActive = step(0.3, brightness);
    let bloomBoost = 1.0 + isActive * 2.5;
    let saturated = mix(vec3f(dot(baseColor, vec3f(0.299, 0.587, 0.114))), baseColor, 1.0 + isActive * 0.5);

    // Combine: glowing core + rim highlight + depth fog
    var c = saturated * glow * bloomBoost * depthFade;
    c += vec3f(rim * depthFade * 0.5); // subtle rim light
    c = mix(c, fogColor, depthNorm * 0.6); // atmospheric fog blend

    // HDR-like tone mapping for dramatic range
    c = c / (c + vec3f(0.8)); // Reinhard tonemap
    c = pow(c, vec3f(0.9)); // slight gamma for punch

    return vec4f(c, 1.0);
}
`;
const WIREFRAME_SHADER_WGSL = /* wgsl */`
struct WireCam {
    viewProj: mat4x4f,
    model: mat4x4f,
    color: vec4f,
};
@group(0) @binding(0) var<uniform> wcam: WireCam;

@vertex
fn vsWire(@location(0) pos: vec3f) -> @builtin(position) vec4f {
    let world = (wcam.model * vec4f(pos, 1.0)).xyz;
    return wcam.viewProj * vec4f(world, 1.0);
}
@fragment
fn fsWire() -> @location(0) vec4f {
    return wcam.color;
}
`;


// ============================================================
// ICOSAHEDRON GEOMETRY ‚Äî Port of OptimizedSphereGenerator
// ============================================================
function generateIcosahedron() {
    const t = (1 + Math.sqrt(5)) / 2;
    const raw = [
        [-1,t,0],[1,t,0],[-1,-t,0],[1,-t,0],
        [0,-1,t],[0,1,t],[0,-1,-t],[0,1,-t],
        [t,0,-1],[t,0,1],[-t,0,-1],[-t,0,1]
    ];
    const verts = raw.map(v => { const l = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return [v[0]/l, v[1]/l, v[2]/l]; });
    const tris = [
        0,11,5, 0,5,1, 0,1,7, 0,7,10, 0,10,11,
        1,5,9, 5,11,4, 11,10,2, 10,7,6, 7,1,8,
        3,9,4, 3,4,2, 3,2,6, 3,6,8, 3,8,9,
        4,9,5, 2,4,11, 6,2,10, 8,6,7, 9,8,1
    ];
    // Subdivide once ‚Üí 42 verts, 80 tris (Medium quality)
    return subdivideSphere(verts, tris, 1);
}

function subdivideSphere(verts, tris, levels) {
    let v = verts.slice(), t = tris.slice();
    for (let l = 0; l < levels; l++) {
        const cache = {};
        const newT = [];
        const midpoint = (a, b) => {
            const key = Math.min(a,b) + '_' + Math.max(a,b);
            if (cache[key] !== undefined) return cache[key];
            const mx = (v[a][0]+v[b][0])/2, my = (v[a][1]+v[b][1])/2, mz = (v[a][2]+v[b][2])/2;
            const len = Math.sqrt(mx*mx+my*my+mz*mz);
            v.push([mx/len, my/len, mz/len]);
            cache[key] = v.length - 1;
            return cache[key];
        };
        for (let i = 0; i < t.length; i += 3) {
            const a = t[i], b = t[i+1], c = t[i+2];
            const m0 = midpoint(a,b), m1 = midpoint(b,c), m2 = midpoint(c,a);
            newT.push(a,m0,m2, b,m1,m0, c,m2,m1, m0,m1,m2);
        }
        t = newT;
    }
    // Build float arrays with normals (normals = positions for unit sphere)
    const positions = new Float32Array(v.length * 3);
    const normals = new Float32Array(v.length * 3);
    for (let i = 0; i < v.length; i++) {
        positions[i*3] = v[i][0]; positions[i*3+1] = v[i][1]; positions[i*3+2] = v[i][2];
        normals[i*3] = v[i][0]; normals[i*3+1] = v[i][1]; normals[i*3+2] = v[i][2];
    }
    return { positions, normals, indices: new Uint16Array(t), vertexCount: v.length, indexCount: t.length };
}

function generateWireframeBox(halfSize) {
    const s = halfSize;
    // 8 corners, 12 edges = 24 line vertices
    const corners = [
        [-s,-s,-s],[s,-s,-s],[s,-s,s],[-s,-s,s],
        [-s,s,-s],[s,s,-s],[s,s,s],[-s,s,s]
    ];
    const edges = [
        0,1, 1,2, 2,3, 3,0,  // bottom
        4,5, 5,6, 6,7, 7,4,  // top
        0,4, 1,5, 2,6, 3,7   // verticals
    ];
    const verts = new Float32Array(edges.length * 3);
    for (let i = 0; i < edges.length; i++) {
        const c = corners[edges[i]];
        verts[i*3] = c[0]; verts[i*3+1] = c[1]; verts[i*3+2] = c[2];
    }
    return { positions: verts, vertexCount: edges.length };
}


// ============================================================
// MATH UTILITIES
// ============================================================
const mat4 = {
    create: () => new Float32Array(16),
    identity: (o) => { o.fill(0); o[0]=o[5]=o[10]=o[15]=1; return o; },
    perspective: (o, fov, aspect, near, far) => {
        const f = 1/Math.tan(fov/2), nf = 1/(near-far);
        o.fill(0); o[0]=f/aspect; o[5]=f; o[10]=(far+near)*nf; o[11]=-1; o[14]=2*far*near*nf;
        return o;
    },
    lookAt: (o, eye, center, up) => {
        let fx=center[0]-eye[0], fy=center[1]-eye[1], fz=center[2]-eye[2];
        let len=Math.sqrt(fx*fx+fy*fy+fz*fz); fx/=len; fy/=len; fz/=len;
        let sx=fy*up[2]-fz*up[1], sy=fz*up[0]-fx*up[2], sz=fx*up[1]-fy*up[0];
        len=Math.sqrt(sx*sx+sy*sy+sz*sz); sx/=len; sy/=len; sz/=len;
        const ux=sy*fz-sz*fy, uy=sz*fx-sx*fz, uz=sx*fy-sy*fx;
        o[0]=sx;o[1]=ux;o[2]=-fx;o[3]=0;
        o[4]=sy;o[5]=uy;o[6]=-fy;o[7]=0;
        o[8]=sz;o[9]=uz;o[10]=-fz;o[11]=0;
        o[12]=-(sx*eye[0]+sy*eye[1]+sz*eye[2]);
        o[13]=-(ux*eye[0]+uy*eye[1]+uz*eye[2]);
        o[14]=(fx*eye[0]+fy*eye[1]+fz*eye[2]);
        o[15]=1;
        return o;
    },
    multiply: (o, a, b) => {
        for (let i=0;i<4;i++) for (let j=0;j<4;j++) {
            o[j*4+i]=a[i]*b[j*4]+a[4+i]*b[j*4+1]+a[8+i]*b[j*4+2]+a[12+i]*b[j*4+3];
        }
        return o;
    },
    rotateY: (o, a, rad) => {
        const s=Math.sin(rad),c=Math.cos(rad),
        a00=a[0],a01=a[1],a02=a[2],a03=a[3],
        a20=a[8],a21=a[9],a22=a[10],a23=a[11];
        for(let i=0;i<16;i++) o[i]=a[i];
        o[0]=a00*c+a20*s; o[1]=a01*c+a21*s; o[2]=a02*c+a22*s; o[3]=a03*c+a23*s;
        o[8]=a20*c-a00*s; o[9]=a21*c-a01*s; o[10]=a22*c-a02*s; o[11]=a23*c-a03*s;
        return o;
    },
    rotateX: (o, a, rad) => {
        const s=Math.sin(rad),c=Math.cos(rad),
        a10=a[4],a11=a[5],a12=a[6],a13=a[7],
        a20=a[8],a21=a[9],a22=a[10],a23=a[11];
        for(let i=0;i<16;i++) o[i]=a[i];
        o[4]=a10*c+a20*s; o[5]=a11*c+a21*s; o[6]=a12*c+a22*s; o[7]=a13*c+a23*s;
        o[8]=a20*c-a10*s; o[9]=a21*c-a11*s; o[10]=a22*c-a12*s; o[11]=a23*c-a13*s;
        return o;
    },
};


// ============================================================
// SYNTHETIC DATA GENERATOR
// Matches VarjoNeuronDataManager HDF5 buffer layout exactly
// ============================================================
function generateSyntheticData(neuronCount, pctActive = 0.35) {
    console.log(`Generating synthetic data: ${neuronCount} neurons...`);

    // Positions ‚Äî curved hippocampal structure
    // Mimics the mouse CA1 hippocampus shape from the real dataset
    const positions = new Float32Array(neuronCount * 3);
    const xRange = 2000, yRange = 4000, zRange = 2000;
    for (let i = 0; i < neuronCount; i++) {
        const t = i / neuronCount;
        // Curved band shape (hippocampus-like)
        const angle = t * Math.PI * 1.5;
        const r = 1500 + Math.random() * 800;
        const x = r * Math.cos(angle) + (Math.random() - 0.5) * 400;
        const y = t * yRange + (Math.random() - 0.5) * 300;
        const z = r * Math.sin(angle) + (Math.random() - 0.5) * 400;
        positions[i * 3]     = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
    }

    // Spike data ‚Äî matching flat array layout from VarjoNeuronDataManager
    const activeNeurons = Math.floor(neuronCount * pctActive);
    const maxSpikesPerNeuron = 82; // Matches thesis Table 23
    const totalSpikeSlots = neuronCount * maxSpikesPerNeuron;
    const spikeTimes = new Float32Array(totalSpikeSlots);
    const spikeCounts = new Int32Array(neuronCount);

    // Fill with padding value (matches Unity float.MaxValue sentinel)
    spikeTimes.fill(3.4028235e+38);

    const minTime = 0.0;
    const maxTime = 995.2; // ms ‚Äî matches thesis spike event duration
    let totalSpikes = 0;

    // Generate spike patterns for active neurons
    for (let i = 0; i < neuronCount; i++) {
        if (Math.random() > pctActive) continue;
        // Variable spike count per neuron (realistic distribution)
        const nSpikes = Math.floor(Math.random() * maxSpikesPerNeuron * 0.8) + 1;
        const clampedSpikes = Math.min(nSpikes, maxSpikesPerNeuron);
        spikeCounts[i] = clampedSpikes;
        totalSpikes += clampedSpikes;

        const baseIdx = i * maxSpikesPerNeuron;
        // Generate sorted spike times
        const times = [];
        for (let s = 0; s < clampedSpikes; s++) {
            times.push(minTime + Math.random() * (maxTime - minTime));
        }
        times.sort((a, b) => a - b);
        for (let s = 0; s < clampedSpikes; s++) {
            spikeTimes[baseIdx + s] = times[s];
        }
    }

    // Find max spike count for gradient normalisation
    let maxSC = 0;
    for (let i = 0; i < neuronCount; i++) {
        if (spikeCounts[i] > maxSC) maxSC = spikeCounts[i];
    }

    console.log(`Generated: ${neuronCount} neurons, ${totalSpikes} spikes, maxSpikes/neuron=${maxSC}`);
    return { positions, spikeTimes, spikeCounts, maxSpikesPerNeuron, minTime, maxTime, totalSpikes, maxSpikeCount: maxSC };
}


// ============================================================
// MAIN APPLICATION
// ============================================================
class NeuroConstellationWeb {

    constructor() {
        // State
        this.config = {
            mode: 0,  // 0=Real-Time Activity, 1=Recruitment Map, 2=Forward Preview, 3=Activity Persistence, 4=Firing Rate Map, 5=Spike History Trail
            neuronScale: 1.0,
            pointSize: 0.01,
            inactiveSize: 1.0,
            activeSize: 2.0,
            playbackSpeed: 0.01,
            activationWindow: 1.0,
            showContainer: false,
            autoRotate: false,
            datasetPct: 100,
            inactiveColor: [0.15, 0.35, 1.0, 1.0],   // deep electric blue
            activeColor:   [1.0, 0.25, 0.05, 1.0],    // hot orange-red
            bgColor:       [0.01, 0.015, 0.04],        // background
            gradLow:  [0.1, 0.15, 0.9, 1.0],    // deep blue
            gradMid:  [0.0, 0.9, 1.0, 1.0],     // electric cyan
            gradHigh: [1.0, 0.9, 0.0, 1.0],     // bright yellow
            gradMax:  [1.0, 0.15, 0.0, 1.0],    // hot red
        };

        // Camera (orbit)
        this.camera = {
            distance: 8,
            rotX: 0.5,   // pitch
            rotY: 0,     // yaw
            panX: 0, panY: 0,
            fov: 75 * Math.PI / 180,
        };

        // Playback
        this.currentTime = 0;
        this.minTime = 0;
        this.maxTime = 1000;
        this.isPlaying = true;
        this.lastFrameTs = 0;

        // Model rotation (auto-rotate + container)
        this.modelRotY = 0;

        // GPU
        this.device = null;
        this.ctx = null;

        // Data
        this.data = null;
        this.neuronCount = 0;
        this.normPositions = null;

        // Recording
        this.isRecording = false;
        this.mediaRecorder = null;
        this.recordedChunks = [];
        this.recordStartTime = 0;

        // Stats
        this.fps = 0;
        this.frameCount = 0;
        this.fpsTimer = 0;
        this.uiVisible = true;

        // Setup intro
        this.setupIntro();
    }

    setupIntro() {
        document.getElementById('enterBtn').addEventListener('click', () => {
            document.getElementById('introOverlay').classList.add('hidden');
            setTimeout(() => {
                document.getElementById('introOverlay').style.display = 'none';
                this.startInit();
            }, 800);
        });
    }

    async startInit() {
        const loading = document.getElementById('loadingOverlay');
        loading.classList.add('visible');
        try {
            await this.initWebGPU();
        } catch(e) {
            console.error('Init failed:', e);
            this.showError(e.message);
        }
    }

    showError(msg) {
        document.getElementById('loadingOverlay').classList.remove('visible');
        const overlay = document.getElementById('errorOverlay');
        overlay.classList.add('visible');
        // Show actual error message
        const errBox = overlay.querySelector('.err-msg') || overlay.querySelector('p');
        if (errBox) errBox.textContent = msg;
        console.error('Fatal:', msg);
    }

    setProgress(pct, status) {
        document.getElementById('progressFill').style.width = pct + '%';
        document.getElementById('loadingStatus').textContent = status;
    }

    async initWebGPU() {
        // 1. Check WebGPU support
        if (!navigator.gpu) {
            throw new Error('WebGPU not supported in this browser');
        }
        this.setProgress(10, 'Requesting GPU adapter...');

        let adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
        if (!adapter) {
            // Fallback: try without power preference
            adapter = await navigator.gpu.requestAdapter();
        }
        if (!adapter) throw new Error('No GPU adapter found ‚Äî your browser may not support WebGPU');

        // Store GPU info
        const gpuInfo = adapter.info || {};
        this.gpuName = gpuInfo.description || gpuInfo.architecture || gpuInfo.vendor || 'WebGPU';
        const gpuEl = document.getElementById('pGPU');
        if (gpuEl) gpuEl.textContent = this.gpuName;

        this.setProgress(20, 'Requesting GPU device...');
        this.device = await adapter.requestDevice({
            requiredLimits: {
                maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
                maxBufferSize: adapter.limits.maxBufferSize,
            }
        });

        // 2. Setup canvas
        const canvas = document.getElementById('gpuCanvas');
        canvas.width = window.innerWidth * devicePixelRatio;
        canvas.height = window.innerHeight * devicePixelRatio;
        canvas.style.width = '100%';
        canvas.style.height = '100%';

        this.ctx = canvas.getContext('webgpu');
        this.presentFormat = navigator.gpu.getPreferredCanvasFormat();
        this.ctx.configure({
            device: this.device,
            format: this.presentFormat,
            alphaMode: 'opaque',
        });
        this.canvas = canvas;

        // 3. Create depth texture
        this.setProgress(30, 'Creating depth buffer...');
        this.createDepthTexture();

        // 4. No data yet ‚Äî buffers created when user loads a dataset
        this.setProgress(40, 'Initialising...');
        this.dataLoaded = false;
        this.neuronCount = 0;
        this.minTime = 0;
        this.maxTime = 1000;
        this.currentTime = 0;

        // 5. Create pipelines (these are data-independent)
        this.setProgress(60, 'Compiling WGSL shaders...');
        await this.createPipelines();

        // 6. Create geometry (sphere mesh ‚Äî data-independent)
        this.setProgress(75, 'Generating icosahedron mesh...');
        this.createGeometry();

        // 7. Setup wireframe
        this.setProgress(80, 'Building wireframe container...');
        this.createWireframe();

        // 8. Setup controls
        this.setProgress(90, 'Setting up controls...');
        this.setupControls();

        // 10. Update UI
        this.setProgress(95, 'Finalising...');
        this.updateHeaderStats();
        document.getElementById('tlTotal').textContent = '‚Äî';

        // 11. Start rendering
        this.setProgress(100, 'Ready ‚Äî load a dataset to begin');
        document.getElementById('loadingSub').textContent = 'WebGPU initialised successfully';
        setTimeout(() => {
            const lo = document.getElementById('loadingOverlay');
            lo.classList.add('fade');
            setTimeout(() => { lo.classList.remove('visible'); lo.classList.remove('fade'); }, 500);
        }, 400);

        this.lastFrameTs = performance.now();
        this.fpsTimer = performance.now();
        requestAnimationFrame((t) => this.frame(t));
    }

    createDepthTexture() {
        if (this.depthTexture) this.depthTexture.destroy();
        this.depthTexture = this.device.createTexture({
            size: [this.canvas.width, this.canvas.height],
            format: 'depth24plus',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
        this.depthView = this.depthTexture.createView();
    }

    createBuffers() {
        const d = this.device;
        const n = this.neuronCount;

        // Position buffer ‚Äî vec3f per neuron
        // Normalise positions to fit in view (auto-scale to ¬±1.75 cube)
        const normPos = new Float32Array(n * 3);
        let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity,minZ=Infinity,maxZ=-Infinity;
        for (let i=0;i<n;i++) {
            const x=this.data.positions[i*3], y=this.data.positions[i*3+1], z=this.data.positions[i*3+2];
            if(x<minX)minX=x; if(x>maxX)maxX=x;
            if(y<minY)minY=y; if(y>maxY)maxY=y;
            if(z<minZ)minZ=z; if(z>maxZ)maxZ=z;
        }
        const cx=(minX+maxX)/2, cy=(minY+maxY)/2, cz=(minZ+maxZ)/2;
        const range = Math.max(maxX-minX, maxY-minY, maxZ-minZ);
        const scale = range > 0 ? 3.5 / range : 1;

        console.log(`Position bounds: X[${minX.toFixed(6)}, ${maxX.toFixed(6)}] Y[${minY.toFixed(6)}, ${maxY.toFixed(6)}] Z[${minZ.toFixed(6)}, ${maxZ.toFixed(6)}]`);
        console.log(`Centre: (${cx.toFixed(6)}, ${cy.toFixed(6)}, ${cz.toFixed(6)}), range=${range.toFixed(6)}, scale=${scale.toFixed(2)}`);

        for (let i=0;i<n;i++) {
            normPos[i*3]   = (this.data.positions[i*3]   - cx) * scale;
            normPos[i*3+1] = (this.data.positions[i*3+1] - cy) * scale;
            normPos[i*3+2] = (this.data.positions[i*3+2] - cz) * scale;
        }

        // Auto-calculate point size based on neuron density
        // Estimate average spacing: cube_root(volume / neuronCount)
        const vol = (maxX-minX) * (maxY-minY) * (maxZ-minZ) * scale * scale * scale;
        const avgSpacing = Math.pow(vol / Math.max(1, n), 1/3);
        this.config.pointSize = avgSpacing * 0.25; // 25% of average spacing
        console.log(`Auto point size: ${this.config.pointSize.toFixed(6)} (spacing=${avgSpacing.toFixed(6)}, neurons=${n})`);

        // VERIFY normalised positions
        let nMinX=Infinity,nMaxX=-Infinity,nMinY=Infinity,nMaxY=-Infinity,nMinZ=Infinity,nMaxZ=-Infinity;
        for (let i=0;i<n;i++){
            const x=normPos[i*3],y=normPos[i*3+1],z=normPos[i*3+2];
            if(x<nMinX)nMinX=x;if(x>nMaxX)nMaxX=x;
            if(y<nMinY)nMinY=y;if(y>nMaxY)nMaxY=y;
            if(z<nMinZ)nMinZ=z;if(z>nMaxZ)nMaxZ=z;
        }
        console.log(`NORMALISED bounds: X[${nMinX.toFixed(3)}, ${nMaxX.toFixed(3)}] Y[${nMinY.toFixed(3)}, ${nMaxY.toFixed(3)}] Z[${nMinZ.toFixed(3)}, ${nMaxZ.toFixed(3)}]`);
        console.log(`First normalised: (${normPos[0].toFixed(4)}, ${normPos[1].toFixed(4)}, ${normPos[2].toFixed(4)})`);
        console.log(`Neuron count for GPU: ${n}`);

        // Update UI slider
        document.getElementById('scaleVal').textContent = '1.0x';

        this.positionBuffer = d.createBuffer({
            size: normPos.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Float32Array(this.positionBuffer.getMappedRange()).set(normPos);
        this.positionBuffer.unmap();
        this.normPositions = normPos; // Store for minimap

        // Spike times buffer ‚Äî flat array, neuronId * maxSpikes + spikeIdx
        const stSize = this.data.spikeTimes.byteLength;
        console.log(`Buffer sizes: positions=${(normPos.byteLength/1024/1024).toFixed(1)}MB, spikeTimes=${(stSize/1024/1024).toFixed(1)}MB, spikeCounts=${(this.data.spikeCounts.byteLength/1024/1024).toFixed(1)}MB, activations=${(n*16/1024/1024).toFixed(1)}MB`);

        // Check against device limits
        const maxBufSize = d.limits.maxStorageBufferBindingSize;
        console.log(`GPU maxStorageBufferBindingSize: ${(maxBufSize/1024/1024).toFixed(0)}MB`);
        if (stSize > maxBufSize) {
            console.warn(`‚ö† Spike times buffer (${(stSize/1024/1024).toFixed(0)}MB) exceeds GPU limit (${(maxBufSize/1024/1024).toFixed(0)}MB)!`);
            console.warn(`Reducing maxSpikesPerNeuron to fit...`);
            const maxAllowedSpikes = Math.floor(maxBufSize / (n * 4));
            this.data.maxSpikesPerNeuron = Math.max(1, maxAllowedSpikes);
            // Rebuild spike times with reduced max
            const reduced = new Float32Array(n * this.data.maxSpikesPerNeuron);
            reduced.fill(3.4028235e+38);
            const oldMax = this.data.spikeTimes.length / n;
            for (let i = 0; i < n; i++) {
                const count = Math.min(this.data.spikeCounts[i], this.data.maxSpikesPerNeuron);
                this.data.spikeCounts[i] = count;
                for (let s = 0; s < count; s++) {
                    reduced[i * this.data.maxSpikesPerNeuron + s] = this.data.spikeTimes[i * oldMax + s];
                }
            }
            this.data.spikeTimes = reduced;
            console.log(`Reduced to maxSpikesPerNeuron=${this.data.maxSpikesPerNeuron}, buffer=${(reduced.byteLength/1024/1024).toFixed(1)}MB`);
        }

        this.spikeTimesBuffer = d.createBuffer({
            size: this.data.spikeTimes.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Float32Array(this.spikeTimesBuffer.getMappedRange()).set(this.data.spikeTimes);
        this.spikeTimesBuffer.unmap();

        // Spike counts buffer
        this.spikeCountsBuffer = d.createBuffer({
            size: this.data.spikeCounts.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Int32Array(this.spikeCountsBuffer.getMappedRange()).set(this.data.spikeCounts);
        this.spikeCountsBuffer.unmap();

        // Activation buffer ‚Äî output from compute, input to render
        // vec4f per neuron (activity, r, g, b) = 16 bytes
        this.activationBuffer = d.createBuffer({
            size: n * 16, usage: GPUBufferUsage.STORAGE,
        });

        // ModeData buffer ‚Äî persistent per-neuron float for heatmap accumulation
        this.modeDataBuffer = d.createBuffer({
            size: n * 4, usage: GPUBufferUsage.STORAGE,
        });

        // Log GPU memory
        const totalBytes = normPos.byteLength + this.data.spikeTimes.byteLength +
            this.data.spikeCounts.byteLength + n * 16 + n * 4;
        this.gpuMemoryMB = totalBytes / (1024*1024);
        console.log(`GPU buffers: ${this.gpuMemoryMB.toFixed(1)} MB`);
    }

    async createPipelines() {
        const d = this.device;

        // ---- UNIFORM BUFFERS (data-independent, created once) ----
        this.computeUniformSize = 128;
        this.computeUniformBuffer = d.createBuffer({
            size: this.computeUniformSize, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.renderUniformSize = 176;
        this.renderUniformBuffer = d.createBuffer({
            size: this.renderUniformSize, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this.wireUniformSize = 144;
        this.wireUniformBuffer = d.createBuffer({
            size: this.wireUniformSize, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        // ---- COMPUTE PIPELINE ----
        const computeModule = d.createShaderModule({ code: COMPUTE_SHADER_WGSL });
        const computeInfo = await computeModule.getCompilationInfo();
        for (const msg of computeInfo.messages) {
            if (msg.type === 'error') {
                throw new Error(`WGSL Compute Error: ${msg.message} (line ${msg.lineNum})`);
            }
        }
        this.computeBGL = d.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
            ]
        });
        this.computePipeline = d.createComputePipeline({
            layout: d.createPipelineLayout({ bindGroupLayouts: [this.computeBGL] }),
            compute: { module: computeModule, entryPoint: 'main' },
        });

        // ---- RENDER PIPELINE ----
        const renderModule = d.createShaderModule({ code: RENDER_SHADER_WGSL });
        this.renderBGL = d.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                { binding: 1, visibility: GPUShaderStage.VERTEX, buffer: { type: 'read-only-storage' } },
                { binding: 2, visibility: GPUShaderStage.VERTEX, buffer: { type: 'read-only-storage' } },
            ]
        });
        this.renderPipeline = d.createRenderPipeline({
            layout: d.createPipelineLayout({ bindGroupLayouts: [this.renderBGL] }),
            vertex: {
                module: renderModule, entryPoint: 'vsMain',
                buffers: [
                    { arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] },
                    { arrayStride: 12, attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x3' }] },
                ],
            },
            fragment: {
                module: renderModule, entryPoint: 'fsMain',
                targets: [{ format: this.presentFormat }],
            },
            primitive: { topology: 'triangle-list', cullMode: 'back' },
            depthStencil: { format: 'depth24plus', depthWriteEnabled: true, depthCompare: 'less' },
        });

        // ---- WIREFRAME PIPELINE ----
        const wireModule = d.createShaderModule({ code: WIREFRAME_SHADER_WGSL });

        // ---- BILLBOARD QUAD PIPELINE (6 verts per neuron, instanced) ----
        const pointModule = d.createShaderModule({ code: POINT_SHADER_WGSL });
        this.pointPipeline = d.createRenderPipeline({
            layout: d.createPipelineLayout({ bindGroupLayouts: [this.renderBGL] }),
            vertex: {
                module: pointModule, entryPoint: 'vsPoint',
                buffers: [],
            },
            fragment: {
                module: pointModule, entryPoint: 'fsPoint',
                targets: [{ format: this.presentFormat }],
            },
            primitive: { topology: 'triangle-list' },
            depthStencil: { format: 'depth24plus', depthWriteEnabled: true, depthCompare: 'less' },
        });

        this.wireBGL = d.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
            ]
        });
        this.wirePipeline = d.createRenderPipeline({
            layout: d.createPipelineLayout({ bindGroupLayouts: [this.wireBGL] }),
            vertex: {
                module: wireModule, entryPoint: 'vsWire',
                buffers: [{ arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] }],
            },
            fragment: {
                module: wireModule, entryPoint: 'fsWire',
                targets: [{ format: this.presentFormat, blend: {
                    color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha' },
                    alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha' },
                }}],
            },
            primitive: { topology: 'line-list' },
            depthStencil: { format: 'depth24plus', depthWriteEnabled: false, depthCompare: 'less' },
        });
        this.wireBindGroup = d.createBindGroup({
            layout: this.wireBGL,
            entries: [{ binding: 0, resource: { buffer: this.wireUniformBuffer } }],
        });

        // NOTE: compute/render bind groups are created in createBindGroups()
        // after data buffers exist
    }

    // Called after createBuffers() ‚Äî creates bind groups that reference data buffers
    createBindGroups() {
        this.computeBindGroup = this.device.createBindGroup({
            layout: this.computeBGL,
            entries: [
                { binding: 0, resource: { buffer: this.computeUniformBuffer } },
                { binding: 1, resource: { buffer: this.spikeTimesBuffer } },
                { binding: 2, resource: { buffer: this.spikeCountsBuffer } },
                { binding: 3, resource: { buffer: this.activationBuffer } },
                { binding: 4, resource: { buffer: this.modeDataBuffer } },
            ]
        });
        this.renderBindGroup = this.device.createBindGroup({
            layout: this.renderBGL,
            entries: [
                { binding: 0, resource: { buffer: this.renderUniformBuffer } },
                { binding: 1, resource: { buffer: this.positionBuffer } },
                { binding: 2, resource: { buffer: this.activationBuffer } },
            ]
        });
    }

    createGeometry() {
        const sphere = generateIcosahedron();
        this.sphereIndexCount = sphere.indexCount;
        this.sphereVB = this.device.createBuffer({
            size: sphere.positions.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Float32Array(this.sphereVB.getMappedRange()).set(sphere.positions);
        this.sphereVB.unmap();

        this.sphereNB = this.device.createBuffer({
            size: sphere.normals.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Float32Array(this.sphereNB.getMappedRange()).set(sphere.normals);
        this.sphereNB.unmap();

        this.sphereIB = this.device.createBuffer({
            size: sphere.indices.byteLength, usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Uint16Array(this.sphereIB.getMappedRange()).set(sphere.indices);
        this.sphereIB.unmap();
    }

    createWireframe() {
        const wire = generateWireframeBox(2.0); // ¬±2 units
        this.wireVertexCount = wire.vertexCount;
        this.wireVB = this.device.createBuffer({
            size: wire.positions.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
        });
        new Float32Array(this.wireVB.getMappedRange()).set(wire.positions);
        this.wireVB.unmap();
    }

    // ---- CAMERA ----
    getEyePos() {
        const d = this.camera.distance;
        const rx = this.camera.rotX, ry = this.camera.rotY;
        return [
            d * Math.cos(rx) * Math.sin(ry) + this.camera.panX,
            d * Math.sin(rx) + this.camera.panY,
            d * Math.cos(rx) * Math.cos(ry) + this.camera.panX * 0,
        ];
    }

    getViewProj() {
        const aspect = this.canvas.width / this.canvas.height;
        const proj = mat4.perspective(mat4.create(), this.camera.fov, aspect, 0.01, 200);
        const eye = this.getEyePos();
        const view = mat4.lookAt(mat4.create(), eye, [this.camera.panX, this.camera.panY, 0], [0,1,0]);
        return mat4.multiply(mat4.create(), proj, view);
    }

    getModelMatrix() {
        const m = mat4.identity(mat4.create());
        return mat4.rotateY(mat4.create(), m, this.modelRotY);
    }

    // ---- FRAME ----
    frame(ts) {
        requestAnimationFrame((t) => this.frame(t));

        const dt = (ts - this.lastFrameTs);
        this._lastDt = dt;
        this.lastFrameTs = ts;

        // Handle resize
        const cw = this.canvas.clientWidth * devicePixelRatio;
        const ch = this.canvas.clientHeight * devicePixelRatio;
        if (this.canvas.width !== cw || this.canvas.height !== ch) {
            this.canvas.width = cw; this.canvas.height = ch;
            this.createDepthTexture();
            this.ctx.configure({ device: this.device, format: this.presentFormat, alphaMode: 'opaque' });
        }

        // Update time (only if data loaded)
        if (this.isPlaying && this.dataLoaded) {
            // At 1x speed, traverse full dataset in ~10 seconds
            const duration = this.maxTime - this.minTime;
            const targetDuration = 10000; // 10 seconds at 1x
            this.currentTime += dt * this.config.playbackSpeed * (duration / targetDuration);
            if (this.currentTime > this.maxTime) this.currentTime = this.minTime;
        }

        // Auto rotate
        if (this.config.autoRotate) {
            this.modelRotY += 0.001 * dt * 0.06;
        }

        // Update uniforms
        this.writeRenderUniforms();
        this.writeWireUniforms();

        // Encode commands
        const encoder = this.device.createCommandEncoder();

        // Compute pass ‚Äî only if data is loaded
        if (this.dataLoaded) {
            this.writeComputeUniforms();
            const computePass = encoder.beginComputePass();
            computePass.setPipeline(this.computePipeline);
            computePass.setBindGroup(0, this.computeBindGroup);
            const workgroups = Math.ceil(this.neuronCount / 256);
            computePass.dispatchWorkgroups(workgroups);
            computePass.end();
        }

        // Render pass
        const textureView = this.ctx.getCurrentTexture().createView();
        const renderPass = encoder.beginRenderPass({
            colorAttachments: [{
                view: textureView,
                clearValue: { r: this.config.bgColor[0], g: this.config.bgColor[1], b: this.config.bgColor[2], a: 1 },
                loadOp: 'clear', storeOp: 'store',
            }],
            depthStencilAttachment: {
                view: this.depthView,
                depthClearValue: 1.0,
                depthLoadOp: 'clear', depthStoreOp: 'store',
            }
        });

        // Draw wireframe container
        if (this.config.showContainer) {
            renderPass.setPipeline(this.wirePipeline);
            renderPass.setBindGroup(0, this.wireBindGroup);
            renderPass.setVertexBuffer(0, this.wireVB);
            renderPass.draw(this.wireVertexCount);
        }

        // Draw neurons ‚Äî instanced billboard quads
        if (this.dataLoaded) {
            renderPass.setPipeline(this.pointPipeline);
            renderPass.setBindGroup(0, this.renderBindGroup);
            renderPass.draw(6, this.neuronCount); // 6 verts per quad, N instances
        }

        renderPass.end();

        this.device.queue.submit([encoder.finish()]);

        // Screenshot capture ‚Äî must happen right after submit, before next frame clears
        if (this._screenshotPending) {
            this._screenshotPending = false;
            this._doScreenshotCapture();
        }

        // FPS + UI update
        this.frameCount++;
        if (ts - this.fpsTimer >= 1000) {
            this.fps = Math.round(this.frameCount * 1000 / (ts - this.fpsTimer));
            this.frameCount = 0;
            this.fpsTimer = ts;
            this.updatePerfUI();
            this.updateActiveCount();
        }
        this.updateTimelineUI();

        // Minimap update (every 3 frames)
        if (this.dataLoaded && this.normPositions && this.frameCount % 3 === 0) {
            const mm = document.getElementById('minimapPanel');
            if (mm && !mm.classList.contains('hidden')) this.drawMinimap();
        }
        // Recording timer
        if (this.isRecording) {
            const elapsed = Math.floor((Date.now() - this.recordStartTime) / 1000);
            const m = String(Math.floor(elapsed/60)).padStart(2,'0'), s = String(elapsed%60).padStart(2,'0');
            const rt = document.getElementById('recTimer');
            if (rt) rt.textContent = `REC ${m}:${s}`;
        }
    }

    // Count active neurons based on current time and activation window
    // Uses CPU-side spike data (matches compute shader logic)
    updateActiveCount() {
        if (!this.dataLoaded || !this.data) {
            document.getElementById('hActive').textContent = '‚Äî';
            return;
        }
        if (this.config.mode === 1) {
            // Static mode ‚Äî no active concept
            document.getElementById('hActive').textContent = '‚Äî';
            return;
        }
        const t = this.currentTime;
        const w = this.config.activationWindow;
        const maxSPN = this.data.maxSpikesPerNeuron;
        let active = 0;
        // Sample a subset for performance (every 10th neuron)
        const stride = Math.max(1, Math.floor(this.neuronCount / 5000));
        let sampled = 0;
        for (let i = 0; i < this.neuronCount; i += stride) {
            sampled++;
            const sc = this.data.spikeCounts[i];
            if (sc === 0) continue;
            const base = i * maxSPN;
            const count = Math.min(sc, maxSPN);
            for (let s = 0; s < count; s++) {
                const st = this.data.spikeTimes[base + s];
                if (st >= 3.4e+38) break;
                if (Math.abs(st - t) < w) { active++; break; }
            }
        }
        // Extrapolate from sample
        const estimated = Math.round(active * (this.neuronCount / sampled));
        const fmt = (n) => n >= 1e6 ? (n/1e6).toFixed(1)+'M' : n >= 1e3 ? (n/1e3).toFixed(1)+'K' : n.toString();
        document.getElementById('hActive').textContent = fmt(estimated);
    }

    writeComputeUniforms() {
        // Must match WGSL Params struct layout with std140 alignment
        const buf = new ArrayBuffer(this.computeUniformSize);
        const u32 = new Uint32Array(buf);
        const f32 = new Float32Array(buf);

        u32[0] = this.neuronCount;
        u32[1] = this.data.maxSpikesPerNeuron;
        f32[2] = this.currentTime;
        f32[3] = this.config.activationWindow;
        // inactiveColor at offset 16 (vec4f)
        f32[4] = this.config.inactiveColor[0]; f32[5] = this.config.inactiveColor[1];
        f32[6] = this.config.inactiveColor[2]; f32[7] = this.config.inactiveColor[3];
        // activeColor at offset 32
        f32[8] = this.config.activeColor[0]; f32[9] = this.config.activeColor[1];
        f32[10] = this.config.activeColor[2]; f32[11] = this.config.activeColor[3];
        // mode + maxSpikeCount at offset 48
        u32[12] = this.config.mode;
        u32[13] = this.data.maxSpikeCount;
        // deltaTime at offset 56, totalDuration at offset 60
        f32[14] = this._lastDt ? this._lastDt / 1000.0 : 0.016; // seconds
        f32[15] = this.maxTime - this.minTime; // total duration ms
        // gradLow at offset 64
        f32[16] = this.config.gradLow[0]; f32[17] = this.config.gradLow[1];
        f32[18] = this.config.gradLow[2]; f32[19] = this.config.gradLow[3];
        // gradMid at offset 80
        f32[20] = this.config.gradMid[0]; f32[21] = this.config.gradMid[1];
        f32[22] = this.config.gradMid[2]; f32[23] = this.config.gradMid[3];
        // gradHigh at offset 96
        f32[24] = this.config.gradHigh[0]; f32[25] = this.config.gradHigh[1];
        f32[26] = this.config.gradHigh[2]; f32[27] = this.config.gradHigh[3];
        // gradMax at offset 112
        f32[28] = this.config.gradMax[0]; f32[29] = this.config.gradMax[1];
        f32[30] = this.config.gradMax[2]; f32[31] = this.config.gradMax[3];

        this.device.queue.writeBuffer(this.computeUniformBuffer, 0, buf);
    }

    writeRenderUniforms() {
        const buf = new ArrayBuffer(this.renderUniformSize);
        const f32 = new Float32Array(buf);
        const vp = this.getViewProj();
        const model = this.getModelMatrix();
        const eye = this.getEyePos();

        // viewProj mat4x4f at offset 0 (16 floats)
        f32.set(vp, 0);
        // model mat4x4f at offset 16 (16 floats)
        f32.set(model, 16);
        // cameraPosAndSize vec4f at offset 32: xyz=eye, w=pointSize
        f32[32] = eye[0]; f32[33] = eye[1]; f32[34] = eye[2];
        f32[35] = this.config.pointSize * this.config.neuronScale;
        // sizesAndPad vec4f at offset 36: x=inactiveSize, y=activeSize
        f32[36] = this.config.inactiveSize;
        f32[37] = this.config.activeSize;
        f32[38] = 0; f32[39] = 0;
        // lightDirAndPad vec4f at offset 40: xyz=lightDir, w=0
        const ld = [0.5, 0.7, 0.5];
        const ll = Math.sqrt(ld[0]*ld[0]+ld[1]*ld[1]+ld[2]*ld[2]);
        f32[40] = ld[0]/ll; f32[41] = ld[1]/ll; f32[42] = ld[2]/ll;
        f32[43] = 0;

        this.device.queue.writeBuffer(this.renderUniformBuffer, 0, buf);
    }

    writeWireUniforms() {
        const buf = new ArrayBuffer(this.wireUniformSize);
        const f32 = new Float32Array(buf);
        f32.set(this.getViewProj(), 0);
        f32.set(this.getModelMatrix(), 16);
        // color
        f32[32] = 0; f32[33] = 1; f32[34] = 0.53; f32[35] = 0.5; // green-ish, 50% alpha
        this.device.queue.writeBuffer(this.wireUniformBuffer, 0, buf);
    }

    // ---- UI UPDATES ----
    updateHeaderStats() {
        const fmt = (n) => n >= 1e6 ? (n/1e6).toFixed(2)+'M' : n >= 1e3 ? (n/1e3).toFixed(0)+'K' : n.toString();
        document.getElementById('hNeurons').textContent = this.neuronCount > 0 ? fmt(this.neuronCount) : '‚Äî';
        document.getElementById('hSpikes').textContent = this.data ? fmt(this.data.totalSpikes) : '‚Äî';
    }

    updatePerfUI() {
        const el = document.getElementById('pFps');
        el.textContent = this.fps;
        el.className = 'pval ' + (this.fps >= 50 ? 'fps-hi' : this.fps >= 30 ? 'fps-md' : 'fps-lo');
        document.getElementById('pFrame').textContent = (1000/Math.max(1,this.fps)).toFixed(1) + ' ms';
        document.getElementById('pMem').textContent = (this.gpuMemoryMB || 0).toFixed(1) + ' MB';
        document.getElementById('pNeurons').textContent = this.neuronCount.toLocaleString();
    }

    updateTimelineUI() {
        const elapsed = this.currentTime - this.minTime;
        const duration = this.maxTime - this.minTime;
        const pct = duration > 0 ? (elapsed / duration) * 100 : 0;
        document.getElementById('tlFill').style.width = pct + '%';
        document.getElementById('tlTime').textContent = elapsed.toFixed(1) + ' ms';
    }

    // ---- CONTROLS ----
    setupControls() {
        const canvas = this.canvas;

        // Mouse orbit
        let dragging = false, btn = 0, lastX = 0, lastY = 0;
        canvas.addEventListener('mousedown', (e) => {
            dragging = true; btn = e.button; lastX = e.clientX; lastY = e.clientY;
        });
        window.addEventListener('mouseup', () => { dragging = false; });
        window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const dx = e.clientX - lastX, dy = e.clientY - lastY;
            lastX = e.clientX; lastY = e.clientY;
            if (btn === 0) { // rotate
                this.camera.rotY += dx * 0.005;
                this.camera.rotX = Math.max(-1.5, Math.min(1.5, this.camera.rotX + dy * 0.005));
            } else if (btn === 2) { // pan
                this.camera.panX -= dx * 0.005 * this.camera.distance * 0.1;
                this.camera.panY += dy * 0.005 * this.camera.distance * 0.1;
            }
        });
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            this.camera.distance = Math.max(1, Math.min(50, this.camera.distance * (1 + e.deltaY * 0.001)));
        }, { passive: false });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Touch controls
        let touches = [], lastDist = 0;
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touches = Array.from(e.touches);
            if (touches.length === 2) {
                const dx = touches[0].pageX - touches[1].pageX, dy = touches[0].pageY - touches[1].pageY;
                lastDist = Math.sqrt(dx*dx+dy*dy);
            }
            lastX = touches[0]?.pageX || 0; lastY = touches[0]?.pageY || 0;
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const t = Array.from(e.touches);
            if (t.length === 2 && lastDist > 0) {
                const dx = t[0].pageX - t[1].pageX, dy = t[0].pageY - t[1].pageY;
                const dist = Math.sqrt(dx*dx+dy*dy);
                this.camera.distance = Math.max(1, Math.min(50, this.camera.distance / (dist/lastDist)));
                lastDist = dist;
            } else if (t.length === 1) {
                const dx = t[0].pageX - lastX, dy = t[0].pageY - lastY;
                this.camera.rotY += dx * 0.008;
                this.camera.rotX = Math.max(-1.5, Math.min(1.5, this.camera.rotX + dy * 0.008));
                lastX = t[0].pageX; lastY = t[0].pageY;
            }
        }, { passive: false });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); lastDist = 0; }, { passive: false });

        // Resize
        window.addEventListener('resize', () => {
            // Handled in frame loop
        });

        // Keyboard ‚Äî comprehensive controls
        window.addEventListener('keydown', (e) => {
            // Prevent default for all our shortcuts
            const key = e.key;
            // UI toggles
            if (key === 'h' || key === 'H') { e.preventDefault(); this.toggleUI(); }
            if (key === 'c' || key === 'C') { e.preventDefault(); this.togglePanel(); }
            if (key === 'f' || key === 'F') {
                e.preventDefault();
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            }
            // Playback
            if (key === ' ') { e.preventDefault(); this.togglePlayPause(); }
            if (key === 'ArrowLeft')  { e.preventDefault(); this.seekTime(-10); }
            if (key === 'ArrowRight') { e.preventDefault(); this.seekTime(10); }
            // Speed: Up/Down arrows and +/- keys
            if (key === 'ArrowUp')   { e.preventDefault(); this.adjustSpeed(0.2); }
            if (key === 'ArrowDown') { e.preventDefault(); this.adjustSpeed(-0.2); }
            if (key === '+' || key === '=') { e.preventDefault(); this.adjustSpeed(0.1); }
            if (key === '-' || key === '_') { e.preventDefault(); this.adjustSpeed(-0.1); }
            // Activation window: W increase, S decrease (WASD-like)
            if (key === 'w' || key === 'W') { e.preventDefault(); this.adjustWindow(0.5); }
            if (key === 's' || key === 'S') { e.preventDefault(); this.adjustWindow(-0.5); }
            // Neuron scale: Q decrease, E increase
            if (key === 'q' || key === 'Q') { e.preventDefault(); this.adjustScale(-0.1); }
            if (key === 'e' || key === 'E') { e.preventDefault(); this.adjustScale(0.1); }
            // Modes
            if (key === '1') { this.setMode(0); this.showToast('‚ö° Real-Time Activity'); }
            if (key === '2') { this.setMode(1); this.showToast('‚óâ Recruitment Map'); }
            if (key === '3') { this.setMode(2); this.showToast('üîÆ Forward Preview'); }
            if (key === '4') { this.setMode(3); this.showToast('üî• Activity Persistence'); }
            if (key === '5') { this.setMode(4); this.showToast('üìä Firing Rate Map'); }
            if (key === '6') { this.setMode(5); this.showToast('üåä Spike History Trail'); }
            // Camera
            if (key === 'r' || key === 'R') { e.preventDefault(); this.resetCamera(); }
            // Auto rotate
            if (key === 't' || key === 'T') {
                e.preventDefault();
                this.config.autoRotate = !this.config.autoRotate;
                this.showToast(this.config.autoRotate ? '‚Üª Auto Rotate ON' : '‚äò Auto Rotate OFF');
            }
            // Wireframe container
            if (key === 'g' || key === 'G') {
                e.preventDefault();
                this.config.showContainer = !this.config.showContainer;
                this.showToast(this.config.showContainer ? '‚ñ¢ Container ON' : '‚ñ¢ Container OFF');
            }
            // Screenshot, Video, Minimap
            if (key === 'p' || key === 'P') { e.preventDefault(); this.takeScreenshot(); }
            if (key === 'v' || key === 'V') { e.preventDefault(); this.toggleRecording(); }
            if (key === 'm' || key === 'M') { e.preventDefault(); const mm=document.getElementById('minimapPanel'); if(mm) mm.classList.toggle('hidden'); }
        });

        // UI controls
        this.setupSliders();
        this.setupToggles();
        this.setupModeButtons();
        this.setupDatasetButtons();
        this.setupColorPickers();
        this.setupMiscButtons();
    }

    setupSliders() {
        const setupSlider = (id, onChange) => {
            const el = document.getElementById(id);
            const track = el.querySelector('.slider-track');
            const fill = el.querySelector('.slider-fill');
            const thumb = el.querySelector('.slider-thumb');
            const min = parseFloat(el.dataset.min);
            const max = parseFloat(el.dataset.max);
            const step = parseFloat(el.dataset.step) || 0.1;
            let value = parseFloat(el.dataset.value);

            const update = () => {
                const pct = (value - min) / (max - min);
                fill.style.width = (pct * 100) + '%';
                thumb.style.left = (pct * 100) + '%';
            };

            let isDragging = false;
            const handleInput = (clientX) => {
                const rect = track.getBoundingClientRect();
                const pct = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                value = Math.round((min + (max - min) * pct) / step) * step;
                update();
                onChange(value);
            };

            el.addEventListener('mousedown', (e) => { isDragging = true; handleInput(e.clientX); });
            window.addEventListener('mousemove', (e) => { if (isDragging) handleInput(e.clientX); });
            window.addEventListener('mouseup', () => { isDragging = false; });
            el.addEventListener('touchstart', (e) => { isDragging = true; handleInput(e.touches[0].clientX); }, { passive: true });
            el.addEventListener('touchmove', (e) => { if (isDragging) handleInput(e.touches[0].clientX); }, { passive: true });

            update();
            onChange(value);
        };

        setupSlider('sliderScale', (v) => {
            this.config.neuronScale = v;
            document.getElementById('scaleVal').textContent = v.toFixed(1) + 'x';
        });
        setupSlider('sliderSpeed', (v) => {
            this.config.playbackSpeed = v;
            const label = v < 0.01 ? v.toFixed(4) + 'x' : v < 0.1 ? v.toFixed(3) + 'x' : v.toFixed(2) + 'x';
            document.getElementById('speedVal').textContent = label;
        });
        setupSlider('sliderWindow', (v) => {
            this.config.activationWindow = v;
            document.getElementById('windowVal').textContent = v.toFixed(1) + ' ms';
        });
    }

    setupToggles() {
        const setup = (id, onChange) => {
            const el = document.getElementById(id);
            const track = el.querySelector('.toggle-track');
            el.addEventListener('click', () => {
                track.classList.toggle('on');
                onChange(track.classList.contains('on'));
            });
        };
        setup('togContainer', (v) => { this.config.showContainer = v; });
        setup('togRotate', (v) => { this.config.autoRotate = v; });
    }

    setupModeButtons() {
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const modeMap = { spike:0, static:1, hybrid:2, recruit:3, heatmap:4, frequency:5 };
                this.setMode(modeMap[btn.dataset.mode]);
            });
        });
    }

    setMode(m) {
        this.config.mode = m;
        const names = ['Activity','Recruitment','Preview','Persistence','Frequency','Trail'];
        document.getElementById('hMode').textContent = names[m] || 'Activity';
        const modeMap = { spike:0, static:1, hybrid:2, recruit:3, heatmap:4, frequency:5 };
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.classList.toggle('active', modeMap[btn.dataset.mode] === m);
        });
    }

    setupDatasetButtons() {
        document.querySelectorAll('.ds-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                const pct = parseInt(btn.dataset.pct);
                if (pct === this.config.datasetPct) return;
                document.querySelectorAll('.ds-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('dsLabel').textContent = pct + '%';
                this.config.datasetPct = pct;
                await this.reloadWithPercentage(pct);
            });
        });

        // File upload ‚Äî single button, auto-detect format
        document.getElementById('btnLoadData').addEventListener('click', () => {
            document.getElementById('fileInputData').click();
        });
        document.getElementById('fileInputData').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                const file = e.target.files[0];
                const name = file.name.toLowerCase();
                if (name.endsWith('.json')) {
                    this.loadJSONFile(file);
                } else {
                    this.loadBinaryFiles(e.target.files);
                }
            }
        });
        // Synthetic data button
        document.getElementById('btnLoadSynthetic').addEventListener('click', async () => {
            const data = generateSyntheticData(288027);
            await this.applyNewDataset(data, 'Synthetic 288K');
        });
    }

    // ---- JSON DATASET LOADING ----
    // Supports your activity_network.json format:
    // { "positions": [[x,y,z], ...], "spikes": [[neuronId, time], ...] }
    // OR { "positions": [x,y,z,x,y,z,...], "spikes": { "neuronIds": [...], "times": [...] } }
    async loadJSONFile(file) {
        const info = document.getElementById('datasetInfo');
        info.textContent = `Loading ${file.name}...`;
        info.style.color = 'var(--blue)';

        try {
            const text = await file.text();
            info.textContent = 'Parsing JSON...';
            const json = JSON.parse(text);

            // Detect format
            let positions, spikeEvents;

            if (Array.isArray(json.positions) && json.positions.length > 0) {
                if (Array.isArray(json.positions[0])) {
                    // Format: [[x,y,z], [x,y,z], ...]
                    const n = json.positions.length;
                    positions = new Float32Array(n * 3);
                    for (let i = 0; i < n; i++) {
                        positions[i*3]   = json.positions[i][0];
                        positions[i*3+1] = json.positions[i][1];
                        positions[i*3+2] = json.positions[i][2];
                    }
                } else {
                    // Format: flat [x,y,z,x,y,z,...] 
                    positions = new Float32Array(json.positions);
                }
            } else {
                throw new Error('No positions array found in JSON');
            }

            const neuronCount = positions.length / 3;

            // Parse spikes
            if (Array.isArray(json.spikes) && json.spikes.length > 0) {
                if (Array.isArray(json.spikes[0])) {
                    // Format: [[neuronId, time], ...] or [[time, neuronId], ...]
                    spikeEvents = json.spikes;
                } else {
                    // Flat array ‚Äî assume pairs [id, time, id, time, ...]
                    spikeEvents = [];
                    for (let i = 0; i < json.spikes.length; i += 2) {
                        spikeEvents.push([json.spikes[i], json.spikes[i+1]]);
                    }
                }
            } else if (json.spikes && json.spikes.neuronIds) {
                // Format: { neuronIds: [...], times: [...] }
                spikeEvents = [];
                for (let i = 0; i < json.spikes.neuronIds.length; i++) {
                    spikeEvents.push([json.spikes.neuronIds[i], json.spikes.times[i]]);
                }
            }

            info.textContent = `Building GPU buffers (${neuronCount.toLocaleString()} neurons)...`;

            // Convert to flat spike arrays matching Unity layout
            const data = this.buildSpikeBuffers(positions, spikeEvents, neuronCount);
            await this.applyNewDataset(data, file.name);

        } catch (err) {
            console.error('JSON load error:', err);
            info.textContent = `Error: ${err.message}`;
            info.style.color = 'var(--error)';
        }
    }

    // ---- BINARY DATASET LOADING ----
    // Expects files generated by the HDF5-to-binary converter:
    //   positions.bin  ‚Äî Float32Array, N*3 values (x,y,z per neuron)
    //   spikeTimes.bin ‚Äî Float32Array, N*maxSpikes values (flat, padded with 3.4e38)
    //   spikeCounts.bin ‚Äî Int32Array, N values
    //   header.bin     ‚Äî 3x Int32: [neuronCount, maxSpikesPerNeuron, totalSpikes]
    // OR a single combined .bin file with header
    async loadBinaryFiles(files) {
        const info = document.getElementById('datasetInfo');
        info.textContent = 'Loading binary files...';
        info.style.color = 'var(--blue)';

        try {
            const fileMap = {};
            for (const f of files) {
                const name = f.name.toLowerCase();
                fileMap[name] = f;
            }

            // Check if it's a single combined file or multiple files
            if (files.length === 1 && !fileMap['positions.bin']) {
                // Single combined binary file
                const buf = await files[0].arrayBuffer();
                await this.loadCombinedBinary(buf, files[0].name);
                return;
            }

            // Multiple files
            if (!fileMap['positions.bin']) throw new Error('Missing positions.bin');
            if (!fileMap['spiketimes.bin']) throw new Error('Missing spikeTimes.bin');
            if (!fileMap['spikecounts.bin']) throw new Error('Missing spikeCounts.bin');

            const posBuf = await fileMap['positions.bin'].arrayBuffer();
            const stBuf = await fileMap['spiketimes.bin'].arrayBuffer();
            const scBuf = await fileMap['spikecounts.bin'].arrayBuffer();

            const positions = new Float32Array(posBuf);
            const spikeTimes = new Float32Array(stBuf);
            const spikeCounts = new Int32Array(scBuf);
            const neuronCount = spikeCounts.length;
            const maxSpikesPerNeuron = Math.round(spikeTimes.length / neuronCount);

            // Calculate stats
            let minTime = Infinity, maxTime = -Infinity, totalSpikes = 0, maxSC = 0;
            for (let i = 0; i < neuronCount; i++) {
                totalSpikes += spikeCounts[i];
                if (spikeCounts[i] > maxSC) maxSC = spikeCounts[i];
                const base = i * maxSpikesPerNeuron;
                for (let s = 0; s < spikeCounts[i]; s++) {
                    const t = spikeTimes[base + s];
                    if (t < 3.4e38) {
                        if (t < minTime) minTime = t;
                        if (t > maxTime) maxTime = t;
                    }
                }
            }
            if (minTime === Infinity) { minTime = 0; maxTime = 1000; }

            const data = { positions, spikeTimes, spikeCounts, maxSpikesPerNeuron, minTime, maxTime, totalSpikes, maxSpikeCount: maxSC };
            await this.applyNewDataset(data, `${neuronCount} neurons (binary)`);

        } catch (err) {
            console.error('Binary load error:', err);
            info.textContent = `Error: ${err.message}`;
            info.style.color = 'var(--error)';
        }
    }

    // Load single combined binary: [header 12 bytes][positions][spikeTimes][spikeCounts]
    async loadCombinedBinary(buf, fileName) {
        const header = new Int32Array(buf, 0, 3);
        const neuronCount = header[0];
        const maxSpikesPerNeuron = header[1];
        const totalSpikesStored = header[2];

        console.log(`Binary header: neurons=${neuronCount}, maxSpikes=${maxSpikesPerNeuron}, totalStored=${totalSpikesStored}`);

        const posOffset = 12;
        const posSize = neuronCount * 3 * 4;
        const stOffset = posOffset + posSize;
        const stSize = neuronCount * maxSpikesPerNeuron * 4;
        const scOffset = stOffset + stSize;

        console.log(`Offsets: pos=${posOffset}, spikeTimes=${stOffset}, spikeCounts=${scOffset}, fileSize=${buf.byteLength}`);
        console.log(`Expected size: ${scOffset + neuronCount * 4}, actual: ${buf.byteLength}`);

        // Copy data (not views ‚Äî views can't survive buffer transfer)
        const positions = new Float32Array(buf.slice(posOffset, posOffset + posSize));
        const spikeTimes = new Float32Array(buf.slice(stOffset, stOffset + stSize));
        const spikeCounts = new Int32Array(buf.slice(scOffset, scOffset + neuronCount * 4));

        // Debug: check first few positions
        console.log(`First 3 positions: (${positions[0]}, ${positions[1]}, ${positions[2]}), (${positions[3]}, ${positions[4]}, ${positions[5]}), (${positions[6]}, ${positions[7]}, ${positions[8]})`);

        // Scan time range and stats
        let minTime = Infinity, maxTime = -Infinity, totalSpikes = 0, maxSC = 0;
        for (let i = 0; i < neuronCount; i++) {
            const sc = spikeCounts[i];
            totalSpikes += sc;
            if (sc > maxSC) maxSC = sc;
        }

        // Scan a sample of neurons for time range (much faster than scanning all)
        const sampleStride = Math.max(1, Math.floor(neuronCount / 10000));
        for (let i = 0; i < neuronCount; i += sampleStride) {
            const sc = spikeCounts[i];
            if (sc === 0) continue;
            const base = i * maxSpikesPerNeuron;
            for (let s = 0; s < sc; s++) {
                const t = spikeTimes[base + s];
                if (t >= 3.4e38) break;
                if (t < minTime) minTime = t;
                if (t > maxTime) maxTime = t;
            }
        }
        if (minTime === Infinity) { minTime = 0; maxTime = 1000; }

        console.log(`Parsed: ${totalSpikes} spikes, maxSC=${maxSC}, time=[${minTime.toFixed(2)}, ${maxTime.toFixed(2)}] ms`);

        const data = { positions, spikeTimes, spikeCounts, maxSpikesPerNeuron, minTime, maxTime, totalSpikes, maxSpikeCount: maxSC };
        await this.applyNewDataset(data, fileName);
    }

    // Convert raw spike events to flat GPU buffer layout
    // Mirrors VarjoNeuronDataManager.ConvertToFlatArrays
    buildSpikeBuffers(positions, spikeEvents, neuronCount) {
        // Detect format: [neuronId, time] or [time, neuronId]
        // Use heuristic: if first column values are mostly integers in neuron range ‚Üí [id, time]
        let idCol = 0, timeCol = 1;
        if (spikeEvents && spikeEvents.length > 0) {
            const v0 = spikeEvents[0][0], v1 = spikeEvents[0][1];
            const isInt0 = Math.abs(v0 - Math.round(v0)) < 0.01;
            const isInt1 = Math.abs(v1 - Math.round(v1)) < 0.01;
            if (!isInt0 && isInt1) { idCol = 1; timeCol = 0; }
        }

        // Count spikes per neuron
        const counts = new Int32Array(neuronCount);
        if (spikeEvents) {
            for (const ev of spikeEvents) {
                const nid = Math.round(ev[idCol]);
                if (nid >= 0 && nid < neuronCount) counts[nid]++;
            }
        }

        let maxSPN = 0;
        for (let i = 0; i < neuronCount; i++) {
            if (counts[i] > maxSPN) maxSPN = counts[i];
        }
        maxSPN = Math.min(maxSPN, 1000); // Cap like Unity

        // Build flat array
        const flat = new Float32Array(neuronCount * maxSPN);
        flat.fill(3.4028235e+38);
        const idx = new Int32Array(neuronCount);

        // Sort by neuron then time
        const sorted = spikeEvents ? spikeEvents
            .map(ev => ({ id: Math.round(ev[idCol]), time: ev[timeCol] }))
            .filter(ev => ev.id >= 0 && ev.id < neuronCount)
            .sort((a, b) => a.id - b.id || a.time - b.time) : [];

        let minTime = Infinity, maxTime = -Infinity, totalSpikes = 0;
        for (const sp of sorted) {
            if (idx[sp.id] < maxSPN) {
                flat[sp.id * maxSPN + idx[sp.id]] = sp.time;
                idx[sp.id]++;
                totalSpikes++;
                if (sp.time < minTime) minTime = sp.time;
                if (sp.time > maxTime) maxTime = sp.time;
            }
        }
        if (minTime === Infinity) { minTime = 0; maxTime = 1000; }

        // Recalculate counts (capped)
        const cappedCounts = new Int32Array(neuronCount);
        for (let i = 0; i < neuronCount; i++) cappedCounts[i] = Math.min(counts[i], maxSPN);

        let maxSC = 0;
        for (let i = 0; i < neuronCount; i++) { if (cappedCounts[i] > maxSC) maxSC = cappedCounts[i]; }

        return { positions, spikeTimes: flat, spikeCounts: cappedCounts, maxSpikesPerNeuron: maxSPN, minTime, maxTime, totalSpikes, maxSpikeCount: maxSC };
    }

    // Apply a new dataset (from any source) to the GPU
    async applyNewDataset(data, label, isFullDataset = true) {
        const wasPlaying = this.isPlaying;
        this.isPlaying = false;

        // Store full dataset for progressive loading
        if (isFullDataset) {
            this._fullData = {
                positions: new Float32Array(data.positions),
                spikeTimes: new Float32Array(data.spikeTimes),
                spikeCounts: new Int32Array(data.spikeCounts),
                maxSpikesPerNeuron: data.maxSpikesPerNeuron,
            };
        }

        this.data = data;
        this.neuronCount = data.positions.length / 3;
        this.minTime = data.minTime;
        this.maxTime = data.maxTime;
        this.currentTime = this.minTime;

        // Reset percentage buttons only for full dataset loads
        if (isFullDataset) {
            this.config.datasetPct = 100;
            document.querySelectorAll('.ds-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('.ds-btn[data-pct="100"]').classList.add('active');
            document.getElementById('dsLabel').textContent = '100%';
        }

        // Destroy old GPU buffers (if they exist)
        if (this.positionBuffer) this.positionBuffer.destroy();
        if (this.spikeTimesBuffer) this.spikeTimesBuffer.destroy();
        if (this.spikeCountsBuffer) this.spikeCountsBuffer.destroy();
        if (this.activationBuffer) this.activationBuffer.destroy();
        if (this.modeDataBuffer) this.modeDataBuffer.destroy();

        // Recreate GPU buffers
        this.createBuffers();

        // Recreate bind groups (reference new data buffers)
        this.createBindGroups();

        // Update UI
        this.updateHeaderStats();
        document.getElementById('tlTotal').textContent = (this.maxTime - this.minTime).toFixed(1) + ' ms';
        const info = document.getElementById('datasetInfo');
        info.textContent = `${label}: ${this.neuronCount.toLocaleString()} neurons, ${data.totalSpikes.toLocaleString()} spikes`;
        info.style.color = 'var(--primary)';
        this.dataLoaded = true;

        this.isPlaying = wasPlaying;
        console.log(`Dataset loaded: ${this.neuronCount} neurons, ${data.totalSpikes} spikes, GPU: ${this.gpuMemoryMB.toFixed(1)} MB`);
    }

    // Reload current dataset at a given percentage (progressive loading)
    async reloadWithPercentage(pct) {
        // If we have user-loaded data, slice it; otherwise regenerate synthetic
        if (this._fullData) {
            // Slice user data
            const fullN = this._fullData.positions.length / 3;
            const newN = Math.floor(fullN * pct / 100);
            const positions = this._fullData.positions.slice(0, newN * 3);
            const maxSPN = this._fullData.maxSpikesPerNeuron;
            const spikeTimes = new Float32Array(newN * maxSPN);
            spikeTimes.fill(3.4028235e+38);
            const spikeCounts = new Int32Array(newN);
            let totalSpikes = 0, maxSC = 0, minT = Infinity, maxT = -Infinity;
            for (let i = 0; i < newN; i++) {
                spikeCounts[i] = this._fullData.spikeCounts[i];
                if (spikeCounts[i] > maxSC) maxSC = spikeCounts[i];
                totalSpikes += spikeCounts[i];
                const srcBase = i * maxSPN, dstBase = i * maxSPN;
                for (let s = 0; s < spikeCounts[i] && s < maxSPN; s++) {
                    const t = this._fullData.spikeTimes[srcBase + s];
                    spikeTimes[dstBase + s] = t;
                    if (t < 3.4e38) { if (t < minT) minT = t; if (t > maxT) maxT = t; }
                }
            }
            if (minT === Infinity) { minT = 0; maxT = 1000; }
            const data = { positions, spikeTimes, spikeCounts, maxSpikesPerNeuron: maxSPN, minTime: minT, maxTime: maxT, totalSpikes, maxSpikeCount: maxSC };
            await this.applyNewDataset(data, `${pct}% of ${fullN.toLocaleString()} neurons`, false);
        } else {
            // Regenerate synthetic
            const fullCount = 288027;
            const newCount = Math.floor(fullCount * pct / 100);
            const data = generateSyntheticData(newCount);
            await this.applyNewDataset(data, `Synthetic ${pct}%`, false);
        }
    }

    setupColorPickers() {
        const hexToRgb = (hex) => {
            const r = parseInt(hex.slice(1,3),16)/255;
            const g = parseInt(hex.slice(3,5),16)/255;
            const b = parseInt(hex.slice(5,7),16)/255;
            return [r,g,b,1];
        };
        const setup = (swatchId, pickId, hexId, configKey) => {
            const swatch = document.getElementById(swatchId);
            const pick = document.getElementById(pickId);
            const hex = document.getElementById(hexId);
            swatch.addEventListener('click', () => pick.click());
            pick.addEventListener('input', (e) => {
                swatch.style.backgroundColor = e.target.value;
                hex.textContent = e.target.value;
                this.config[configKey] = hexToRgb(e.target.value);
            });
        };
        setup('swatchInactive', 'pickInactive', 'hexInactive', 'inactiveColor');
        setup('swatchActive', 'pickActive', 'hexActive', 'activeColor');
        // Background color picker ‚Äî uses 3-element array not 4
        const bgSwatch = document.getElementById('swatchBg');
        const bgPick = document.getElementById('pickBg');
        const bgHex = document.getElementById('hexBg');
        if (bgSwatch && bgPick) {
            bgSwatch.addEventListener('click', () => bgPick.click());
            bgPick.addEventListener('input', (e) => {
                bgSwatch.style.backgroundColor = e.target.value;
                bgHex.textContent = e.target.value;
                const c = hexToRgb(e.target.value);
                this.config.bgColor = [c[0], c[1], c[2]];
            });
        }
    }

    setupMiscButtons() {
        document.getElementById('btnPlayPause').addEventListener('click', () => this.togglePlayPause());
        // Camera presets handled via inline onclick
        document.getElementById('fabToggle').addEventListener('click', () => this.toggleUI());
        // Header action buttons
        const ssBtn = document.getElementById('btnScreenshot');
        if (ssBtn) ssBtn.addEventListener('click', () => this.takeScreenshot());
        const recBtn = document.getElementById('btnRecord');
        if (recBtn) recBtn.addEventListener('click', () => this.toggleRecording());

        // Panel collapse
        document.getElementById('cpanelToggle').addEventListener('click', () => {
            const body = document.getElementById('cpanelBody');
            body.style.display = body.style.display === 'none' ? 'block' : 'none';
            document.getElementById('cpanelToggle').textContent = body.style.display === 'none' ? '‚ñº' : '‚ñ≤';
        });

        // Timeline click
        document.getElementById('timeline').addEventListener('click', (e) => {
            const rect = e.currentTarget.getBoundingClientRect();
            const pct = (e.clientX - rect.left) / rect.width;
            this.currentTime = this.minTime + pct * (this.maxTime - this.minTime);
        });
    }

    // ---- SCREENSHOT ----
    takeScreenshot() {
        // WebGPU clears canvas after presentation ‚Äî we must capture during render
        // Set flag, then in next frame after render we grab the pixels
        this._screenshotPending = true;
        this.showToast('üì∑ Capturing...');
    }
    _doScreenshotCapture() {
        // Read pixels from current WebGPU texture to an offscreen canvas
        const canvas = this.canvas;
        // Create a temporary 2D canvas and draw the WebGPU canvas onto it
        const tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = canvas.width;
        tmpCanvas.height = canvas.height;
        const ctx2 = tmpCanvas.getContext('2d');
        ctx2.drawImage(canvas, 0, 0);
        tmpCanvas.toBlob(blob => {
            if (!blob) { this.showToast('‚ö† Capture failed'); return; }
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const ts = new Date().toISOString().replace(/[:.]/g,'-').slice(0,19);
            a.download = `NeuroConstellation_${ts}.png`;
            a.href = url; a.click(); URL.revokeObjectURL(url);
            this.showToast('üì∑ Screenshot saved');
        }, 'image/png');
    }

    // ---- VIDEO RECORDING ----
    toggleRecording() {
        if (this.isRecording) this.stopRecording();
        else this.startRecording();
    }
    startRecording() {
        const stream = this.canvas.captureStream(60);
        this.recordedChunks = [];
        try {
            this.mediaRecorder = new MediaRecorder(stream, { mimeType:'video/webm;codecs=vp9', videoBitsPerSecond:8000000 });
        } catch(e) {
            this.mediaRecorder = new MediaRecorder(stream, { mimeType:'video/webm', videoBitsPerSecond:8000000 });
        }
        this.mediaRecorder.ondataavailable = e => { if(e.data.size>0) this.recordedChunks.push(e.data); };
        this.mediaRecorder.onstop = () => {
            const blob = new Blob(this.recordedChunks, {type:'video/webm'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const ts = new Date().toISOString().replace(/[:.]/g,'-').slice(0,19);
            a.download = `NeuroConstellation_${ts}.webm`;
            a.href = url; a.click(); URL.revokeObjectURL(url);
            this.showToast('üé¨ Video saved');
        };
        this.mediaRecorder.start(100);
        this.isRecording = true; this.recordStartTime = Date.now();
        const badge = document.getElementById('recBadge');
        if (badge) badge.classList.add('show');
        this.showToast('‚è∫ Recording started');
    }
    stopRecording() {
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') this.mediaRecorder.stop();
        this.isRecording = false;
        const badge = document.getElementById('recBadge');
        if (badge) badge.classList.remove('show');
    }

    // ---- MINIMAP ----
    drawMinimap() {
        const mc = document.getElementById('minimapCanvas');
        if (!mc || !this.normPositions) return;
        const ctx2 = mc.getContext('2d'), w = mc.width, h = mc.height;
        ctx2.fillStyle = 'rgba(5,5,8,0.95)'; ctx2.fillRect(0,0,w,h);
        const n = this.neuronCount, stride = Math.max(1, Math.floor(n/4000));
        ctx2.fillStyle = 'rgba(0,150,255,0.4)';
        for (let i=0;i<n;i+=stride) {
            const x=this.normPositions[i*3], z=this.normPositions[i*3+2];
            ctx2.fillRect((x/4+0.5)*w, (z/4+0.5)*h, 1.5, 1.5);
        }
        const eye=this.getEyePos(), cx=(eye[0]/4+0.5)*w, cz=(eye[2]/4+0.5)*h;
        ctx2.fillStyle='#00ff88'; ctx2.beginPath(); ctx2.arc(cx,cz,4,0,Math.PI*2); ctx2.fill();
        const dir=Math.atan2(-eye[0],-eye[2]);
        ctx2.strokeStyle='#00ff88'; ctx2.lineWidth=1.5; ctx2.beginPath();
        ctx2.moveTo(cx,cz); ctx2.lineTo(cx+Math.sin(dir)*18,cz+Math.cos(dir)*18); ctx2.stroke();
    }

    // ---- CAMERA PRESETS ----
    setCameraPreset(name) {
        const presets = { front:{rotX:0,rotY:0}, top:{rotX:1.56,rotY:0}, side:{rotX:0,rotY:1.57}, angle:{rotX:0.5,rotY:0.7}, back:{rotX:0,rotY:3.14}, reset:{rotX:0.5,rotY:0} };
        const p = presets[name]; if(!p) return;
        const start={rotX:this.camera.rotX,rotY:this.camera.rotY,panX:this.camera.panX,panY:this.camera.panY};
        const dur=500, t0=performance.now();
        const ease=t=>t<0.5?2*t*t:1-Math.pow(-2*t+2,2)/2;
        const animate=()=>{
            const t=Math.min(1,(performance.now()-t0)/dur), e=ease(t);
            this.camera.rotX=start.rotX+(p.rotX-start.rotX)*e;
            this.camera.rotY=start.rotY+(p.rotY-start.rotY)*e;
            if(name==='reset'){this.camera.panX=start.panX*(1-e);this.camera.panY=start.panY*(1-e);this.modelRotY*=(1-e);}
            if(t<1)requestAnimationFrame(animate);
        };
        animate();
        this.showToast(`üìê ${name.charAt(0).toUpperCase()+name.slice(1)}`);
    }

    togglePlayPause() {
        this.isPlaying = !this.isPlaying;
        document.getElementById('btnPlayPause').textContent = this.isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
        this.showToast(this.isPlaying ? '‚ñ∂ Playing' : '‚è∏ Paused');
    }

    adjustSpeed(delta) {
        // For small speeds, use multiplicative adjustment; for large, additive
        if (delta > 0) {
            this.config.playbackSpeed = Math.min(5.0, this.config.playbackSpeed < 0.1 ? this.config.playbackSpeed * 2 : this.config.playbackSpeed + delta);
        } else {
            this.config.playbackSpeed = Math.max(0.001, this.config.playbackSpeed < 0.1 ? this.config.playbackSpeed / 2 : this.config.playbackSpeed + delta);
        }
        const s = this.config.playbackSpeed;
        const label = s < 0.01 ? s.toFixed(4) + 'x' : s < 0.1 ? s.toFixed(3) + 'x' : s.toFixed(2) + 'x';
        document.getElementById('speedVal').textContent = label;
        this.updateSlider('sliderSpeed', s);
        this.showToast(`‚ö° Speed ${label}`);
    }

    adjustWindow(delta) {
        this.config.activationWindow = Math.max(0.1, Math.min(10.0, this.config.activationWindow + delta));
        this.config.activationWindow = Math.round(this.config.activationWindow * 10) / 10;
        document.getElementById('windowVal').textContent = this.config.activationWindow.toFixed(1) + ' ms';
        this.updateSlider('sliderWindow', this.config.activationWindow);
        this.showToast(`‚óâ Window ${this.config.activationWindow.toFixed(1)} ms`);
    }

    adjustScale(delta) {
        this.config.neuronScale = Math.max(0.1, Math.min(5.0, this.config.neuronScale + delta));
        this.config.neuronScale = Math.round(this.config.neuronScale * 10) / 10;
        document.getElementById('scaleVal').textContent = this.config.neuronScale.toFixed(1) + 'x';
        this.updateSlider('sliderScale', this.config.neuronScale);
        this.showToast(`‚¨§ Scale ${this.config.neuronScale.toFixed(1)}x`);
    }

    seekTime(deltaMs) {
        if (!this.dataLoaded) return;
        this.currentTime += deltaMs;
        if (this.currentTime > this.data.maxTime) this.currentTime = this.data.minTime;
        if (this.currentTime < this.data.minTime) this.currentTime = this.data.maxTime;
        this.showToast(`${deltaMs > 0 ? '‚è©' : '‚è™'} ${this.currentTime.toFixed(1)} ms`);
    }

    togglePanel() {
        const panel = document.getElementById('controlPanel');
        panel.classList.toggle('hidden');
    }

    updateSlider(id, value) {
        const el = document.getElementById(id);
        if (!el) return;
        const min = parseFloat(el.dataset.min);
        const max = parseFloat(el.dataset.max);
        const pct = Math.max(0, Math.min(100, (value - min) / (max - min) * 100));
        const fill = el.querySelector('.slider-fill');
        const thumb = el.querySelector('.slider-thumb');
        if (fill) fill.style.width = pct + '%';
        if (thumb) thumb.style.left = pct + '%';
        el.dataset.value = value;
    }

    showToast(msg) {
        let toast = document.getElementById('kbToast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'kbToast';
            document.body.appendChild(toast);
        }
        toast.textContent = msg;
        toast.className = 'kb-toast show';
        clearTimeout(this._toastTimer);
        this._toastTimer = setTimeout(() => { toast.className = 'kb-toast'; }, 1200);
    }

    resetCamera() {
        this.camera = { distance: 8, rotX: 0.5, rotY: 0, panX: 0, panY: 0, fov: 75 * Math.PI / 180 };
        this.modelRotY = 0;
        this.showToast('‚ü≤ Camera Reset');
    }

    toggleUI() {
        this.uiVisible = !this.uiVisible;
        ['mainHeader','controlPanel','perfMon','infoBar','minimapPanel'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.classList.toggle('hidden', !this.uiVisible);
        });
    }
}

// ---- LAUNCH ----
window.addEventListener('DOMContentLoaded', () => {
    console.log('%c NeuroConstellation Web v1.0.0 ', 'background:#00ff88;color:#050508;font-weight:bold;font-size:14px;padding:4px 8px;border-radius:4px;');
    console.log('%cGPU-Accelerated Browser-Based Neural Network Visualisation', 'color:#0099ff;font-size:11px;');
    console.log('%cSafeer Ali Mirani ¬∑ University of Sassari ¬∑ EBRAINS-Italy', 'color:#888;font-size:10px;');
    console.log('%c6 Validated Modes | WebGPU Compute | Billboard Instancing', 'color:#666;font-size:10px;');
    window._app = new NeuroConstellationWeb();
});
</script>
</body>
</html>
